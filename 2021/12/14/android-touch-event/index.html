<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android 触摸事件分发机制 - 齐欢的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="齐欢的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="齐欢的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Android 中的触摸事件是一个老生常谈的话题了，在 Android 面试中也经常问到，比较考察基础以及解决问题的能力，最近在巩固基础知识，希望通过本文对这个问题有更加深入的理解。"><meta property="og:type" content="blog"><meta property="og:title" content="Android 触摸事件分发机制"><meta property="og:url" content="https://qihuan92.github.io/2021/12/14/android-touch-event/"><meta property="og:site_name" content="齐欢的博客"><meta property="og:description" content="Android 中的触摸事件是一个老生常谈的话题了，在 Android 面试中也经常问到，比较考察基础以及解决问题的能力，最近在巩固基础知识，希望通过本文对这个问题有更加深入的理解。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.unsplash.com/photo-1521931961826-fe48677230a5?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=3570&amp;q=80"><meta property="article:published_time" content="2021-12-14T08:05:54.000Z"><meta property="article:modified_time" content="2024-02-05T02:26:43.115Z"><meta property="article:author" content="齐欢"><meta property="article:tag" content="Android"><meta property="article:tag" content="源码"><meta property="article:tag" content="View"><meta property="article:tag" content="Window"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://images.unsplash.com/photo-1521931961826-fe48677230a5?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=3570&amp;q=80"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://qihuan92.github.io/2021/12/14/android-touch-event/"},"headline":"Android 触摸事件分发机制","image":[],"datePublished":"2021-12-14T08:05:54.000Z","dateModified":"2024-02-05T02:26:43.115Z","author":{"@type":"Person","name":"齐欢"},"publisher":{"@type":"Organization","name":"齐欢的博客","logo":{"@type":"ImageObject","url":{"text":"QiHuan"}}},"description":"Android 中的触摸事件是一个老生常谈的话题了，在 Android 面试中也经常问到，比较考察基础以及解决问题的能力，最近在巩固基础知识，希望通过本文对这个问题有更加深入的理解。"}</script><link rel="canonical" href="https://qihuan92.github.io/2021/12/14/android-touch-event/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">QiHuan</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/qihuan92"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://images.unsplash.com/photo-1521931961826-fe48677230a5?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=3570&amp;q=80" alt="Android 触摸事件分发机制"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-14T08:05:54.000Z" title="2021/12/14 16:05:54">2021-12-14</time>发表</span><span class="level-item"><time dateTime="2024-02-05T02:26:43.115Z" title="2024/2/5 10:26:43">2024-02-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">32 分钟读完 (大约4788个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Android 触摸事件分发机制</h1><div class="content"><p>Android 中的触摸事件是一个老生常谈的话题了，在 Android 面试中也经常问到，比较考察基础以及解决问题的能力，最近在巩固基础知识，希望通过本文对这个问题有更加深入的理解。</p>
<span id="more"></span>

<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>在事件分发的过程中，MotionEvent 对象记录时间的触摸事件，例如点击、移动。</p>
<p>一次完整的 MotionEvent，包含用户触摸屏幕到离开屏幕。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>发生次数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ACTION_DOWN</td>
<td>1</td>
<td>手指触摸时触发</td>
</tr>
<tr>
<td>ACTION_MOVE</td>
<td>1 ~ N</td>
<td>手指在屏幕上滑动时触发</td>
</tr>
<tr>
<td>ACTION_UP</td>
<td>1</td>
<td>手指离开屏幕时触发</td>
</tr>
<tr>
<td>ACTION_CANCEL</td>
<td>0 ~ 1</td>
<td>事件被上层拦截时触发</td>
</tr>
</tbody></table>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>时间的分发流程涉及到三个核心方法 ：</p>
<ul>
<li><p><code>dispatchTouchEvent(MotionEvent event)</code> </p>
<p>事件分发</p>
</li>
<li><p><code>onInterceptTouchEvent(MotionEvent ev)</code></p>
<p>事件拦截，只有 ViewGroup 有</p>
</li>
<li><p><code>onTouchEvent(MotionEvent event)</code></p>
<p>事件响应</p>
</li>
</ul>
<p>事件分发涉及到的类包含 View、ViewGroup 和 Activity 等，他们都能处理触摸事件的分发，但是其方法有些区别。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>View</th>
<th>ViewGroup</th>
<th>Activity</th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatchTouchEvent()</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><code>onInterceptTouchEvent()</code></td>
<td>×</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td><code>onTouchEvent()</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="分发流程"><a href="#分发流程" class="headerlink" title="分发流程"></a>分发流程</h2><p>当 UI 主线程收到底层上报的 input 事件，会调用 <code>InputEventReceiver.dispachInputEvent()</code> 方法。</p>
<p>整个事件分发流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/qihuan92/figurebed/master/input_event_dispatcher.jpeg" alt="input 事件分发流程"></p>
<h3 id="DecorView-dispatchTouchEvent"><a href="#DecorView-dispatchTouchEvent" class="headerlink" title="DecorView.dispatchTouchEvent()"></a><code>DecorView.dispatchTouchEvent()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DecorView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">    <span class="keyword">return</span> cb != <span class="literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">            ? cb.dispatchTouchEvent(ev) : <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity 实现了 <code>Window.Callback</code> 接口，所以事件会分发到 <code>Activity.dispatchTouchEvent</code>。</p>
<h3 id="Activity-dispatchTouchEvent"><a href="#Activity-dispatchTouchEvent" class="headerlink" title="Activity.dispatchTouchEvent()"></a><code>Activity.dispatchTouchEvent()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Activity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// 第一次按下屏幕的方法</span></span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PhoneWindow.superDispatchTouchEvent(ev)</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有 View 处理事件时，调用 Activity.onTouchEvent(ev)</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PhoneWindow-superDispatchTouchEvent"><a href="#PhoneWindow-superDispatchTouchEvent" class="headerlink" title="PhoneWindow.superDispatchTouchEvent()"></a><code>PhoneWindow.superDispatchTouchEvent()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PhoneWindow.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatcTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PhoneWindow 的顶层 View 是 DecorView，接着又会调用 DecorView 的 <code>superDispatcTouchEvent()</code> 方法，在 DecorView 中又调用了父类的 <code>dispatchTouchEvent()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DecorView.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView 的父类为 ViewGroup，接着会调用 ViewGroup 的 <code>dispatchTouchEvent()</code> 方法。</p>
<h3 id="ViewGroup-dispatchTouchEvent"><a href="#ViewGroup-dispatchTouchEvent" class="headerlink" title="ViewGroup.dispatchTouchEvent()"></a><code>ViewGroup.dispatchTouchEvent()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//根据隐私策略而来决定是否过滤本次触摸事件,</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 发生ACTION_DOWN事件, 则取消并清除之前所有的触摸targets</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState(); <span class="comment">// 重置触摸状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发生ACTION_DOWN事件或者已经发生过ACTION_DOWN;才进入此区域，主要功能是拦截器</span></span><br><span class="line">        <span class="comment">//只有发生过ACTION_DOWN事件，则mFirstTouchTarget != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//可通过调用requestDisallowInterceptTouchEvent，不让父View拦截事件</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断是否允许调用拦截器</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">//调用拦截方法</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当没有触摸targets，且不是down事件时，开始持续拦截触摸。</span></span><br><span class="line">            intercepted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不取消事件，同时不拦截事件, 并且是Down事件才进入该区域</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">//把事件分发给所有的子视图，寻找可以获取焦点的视图。</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">childWithAccessibilityFocus</span> <span class="operator">=</span> ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionIndex</span> <span class="operator">=</span> ev.getActionIndex(); <span class="comment">// down事件等于0</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">idBitsToAssign</span> <span class="operator">=</span> split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign); <span class="comment">//清空早先的触摸对象</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">                <span class="comment">//第一次down事件，同时子视图不会空时</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="literal">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// 从视图最上层到下层，获取所有能接收该事件的子视图</span></span><br><span class="line">                    <span class="comment">// 获取一个视图组的先序列表，通过虚拟的Z轴来排序。</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">customOrder</span> <span class="operator">=</span> preorderedList == <span class="literal">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 从最底层的父视图开始遍历， ** 找寻newTouchTarget，并赋予view与 pointerIdBits； ** 如果已经存在找寻newTouchTarget，说明正在接收触摸事件，则跳出循环。 */</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> customOrder</span><br><span class="line">                                ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> (preorderedList == <span class="literal">null</span>)</span><br><span class="line">                                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果当前视图无法获取用户焦点，则跳过本次循环</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果view不可见，或者触摸的坐标点不在view的范围内，则跳过本次循环</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="comment">// 已经开始接收触摸事件,并退出整个循环。</span></span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//重置取消或抬起标志位</span></span><br><span class="line">                        <span class="comment">//如果触摸位置在child的区域内，则把事件分发给子View或ViewGroup</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// 获取TouchDown的时间点</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="comment">// 获取TouchDown的Index</span></span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//获取TouchDown的x,y坐标</span></span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">//添加TouchTarget,则mFirstTouchTarget != null。</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            <span class="comment">//表示以及分发给NewTouchTarget</span></span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 清除视图列表</span></span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="literal">null</span> &amp;&amp; mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将mFirstTouchTarget的链表最后的touchTarget赋给newTouchTarget</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mFirstTouchTarget赋值是在通过addTouchTarget方法获取的；</span></span><br><span class="line">        <span class="comment">// 只有处理ACTION_DOWN事件，才会进入addTouchTarget方法。</span></span><br><span class="line">        <span class="comment">// 这也正是当View没有消费ACTION_DOWN事件，则不会接收其他MOVE,UP等事件的原因</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有触摸target,则由当前ViewGroup来处理</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果View消费ACTION_DOWN事件，那么MOVE,UP等事件相继开始执行</span></span><br><span class="line">            <span class="type">TouchTarget</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">next</span> <span class="operator">=</span> target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果ViewGroup拦截了事件，则会向子View分发ACTION_CANCEL事件</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">cancelChild</span> <span class="operator">=</span> resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="literal">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当发生抬起或取消事件，更新触摸targets</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionIndex</span> <span class="operator">=</span> ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">idBitsToRemove</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//此处大括号，是if (onFilterTouchEventForSecurity(ev))的结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知verifier由于当前时间未处理，那么该事件其余的都将被忽略</span></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>onInterceptTouchEvent()</code> 方法可以实当前 ViewGroup 拦截事件，阻断事件分发流程。</p>
<h4 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent()"></a><code>dispatchTransformedTouchEvent()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel, View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生取消操作时，不再执行后续的任何操作</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldPointerIdBits</span> <span class="operator">=</span> event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newPointerIdBits</span> <span class="operator">=</span> oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于某些原因，发生不一致的操作，那么将抛弃该事件</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分发的主要区域</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="comment">//判断预期的pointer id与事件的pointer id是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//不存在子视图时，ViewGroup调用View.dispatchTouchEvent分发事件，再调用ViewGroup.onTouchEvent来处理事件</span></span><br><span class="line">                handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">offsetX</span> <span class="operator">=</span> mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">offsetY</span> <span class="operator">=</span> mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                <span class="comment">//将触摸事件分发给子ViewGroup或View;</span></span><br><span class="line">                <span class="comment">//如果是ViewGroup，则调用代码(2.1)；</span></span><br><span class="line">                <span class="comment">//如果是View，则调用代码(3.1)；</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY); <span class="comment">//调整该事件的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event); <span class="comment">//拷贝该事件，来创建一个新的MotionEvent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//分离事件，获取包含newPointerIdBits的MotionEvent</span></span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//不存在子视图时，ViewGroup调用View.dispatchTouchEvent分发事件，再调用ViewGroup.onTouchEvent来处理事件</span></span><br><span class="line">        handled = <span class="built_in">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">offsetX</span> <span class="operator">=</span> mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">offsetY</span> <span class="operator">=</span> mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="comment">//将该视图的矩阵进行转换</span></span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将触摸事件分发给子ViewGroup或View;</span></span><br><span class="line">        <span class="comment">//如果是ViewGroup，则调用 ViewGroup 的事件分发方法，如果是View，则调用 View 的事件分发方法处理事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收transformedEvent</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是 ViewGroup 真正处理事件的地方，分发子 View 来处理事件，过滤掉不相干的 pointer ids。当子视图为 null 时，MotionEvent 将会发送给该 ViewGroup。最终调用 <code>View.dispatchTouchEvent()</code> 方法来分发事件。</p>
<h3 id="View-dispatchTouchEvent"><a href="#View-dispatchTouchEvent" class="headerlink" title="View.dispatchTouchEvent()"></a><code>View.dispatchTouchEvent()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">//在Down事件之前，如果存在滚动操作则停止。不存在则不进行操作</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mOnTouchListener.onTouch优先于onTouchEvent。</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//当存在OnTouchListener，且视图状态为ENABLED时，调用onTouch()方法</span></span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>; <span class="comment">//如果已经消费事件，则返回True</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果OnTouch（)没有消费Touch事件则调用OnTouchEvent()</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>; <span class="comment">//如果已经消费事件，则返回True</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理取消或抬起操作</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先由 <code>OnTouchListener.onTouch()</code> 处理事件，如果返回了 <code>true</code> ，表示消费了事件，则不会调用 <code>onTouchEvent()</code> 方法。</p>
<p>若不拦截，继续调用 <code>onTouchEvent()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当View状态为DISABLED，如果可点击或可长按，则返回True，即消费事件</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当View状态为ENABLED，如果可点击或可长按，则返回True，即消费事件;</span></span><br><span class="line">    <span class="comment">//与前面的的结合，可得出结论:只要view是可点击或可长按，则消费该事件.</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">//这是Tap操作，移除长按回调方法</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//调用View.OnClickListener</span></span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="literal">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> <span class="title class_">UnsetPressedState</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mHasPerformedLongPress = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取是否处于可滚动的视图内</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isInScrollingContainer</span> <span class="operator">=</span> isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="literal">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="keyword">new</span> <span class="title class_">CheckForTap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    <span class="comment">//当处于可滚动视图内，则延迟TAP_TIMEOUT，再反馈按压状态，用来判断用户是否想要滚动。默认延时为100ms</span></span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当不再滚动视图内，则立刻反馈按压状态</span></span><br><span class="line">                    setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>); <span class="comment">//检测是否是长按</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        setPressed(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个事件流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/qihuan92/figurebed/master/touch1.jpeg" alt="事件分发流程"></p>
<ul>
<li><p><code>onInterceptTouchEvent()</code>返回值 <code>true</code> 表示事件拦截， <code>onTouch()</code> 或  <code>onTouchEvent()</code> 返回值 <code>true</code> 表示事件消费。</p>
</li>
<li><p>触摸事件先交由 <code>Activity.dispatchTouchEvent()</code>，再一层层往下分发，当中间的 ViewGroup 都不拦截时，进入最底层的 View 后，开始由最底层的 <code>onTouchEvent()</code> 方法来处理，如果一直不消费，则最后返回到<code>Activity.OnTouchEvent()</code>。</p>
</li>
<li><p>ViewGroup 才有 <code>onInterceptTouchEvent()</code> 拦截方法。在分发过程中，中间任何一层 ViewGroup 都可以直接拦截，则不再往下分发，而是交由发生拦截操作的ViewGroup的 <code>onTouchEvent()</code> 来处理。</p>
</li>
<li><p>子 View 可调用 <code>requestDisallowInterceptTouchEvent()</code> 方法，来设置 <code>disallowIntercept = true</code>，从而阻止父 ViewGroup 的 <code>onInterceptTouchEvent()</code> 拦截操作。</p>
</li>
<li><p><code>onTouchEvent()</code> 由下往上冒泡时，当中间任何一层的 <code>onTouchEvent</code> 消费该事件，则不再往上传递，表示事件已处理。</p>
</li>
<li><p>如果 View 没有消费 ACTION_DOWN 事件，则之后的 ACTION_MOVE 等事件都不会再接收。</p>
</li>
<li><p>只要 <code>View.onTouchEvent()</code>是可点击或可长按，则消费该事件。</p>
</li>
<li><p><code>onTouch()</code> 优先于 <code>onTouchEvent()</code> 执行，上面流程图中省略，<code>onTouch()</code> 的位置在 <code>onTouchEvent()</code> 前面。当 <code>onTouch()</code> 返回 <code>true</code>，则不执行 <code>onTouchEvent()</code>，否则会执行 <code>onTouchEvent()</code>。<code>onTouch()</code> 只有 View 设置了<code>OnTouchListener</code>，且是 <code>enable</code> 的才执行该方法。</p>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="事件一定会经过-Activity-吗？"><a href="#事件一定会经过-Activity-吗？" class="headerlink" title="事件一定会经过 Activity 吗？"></a>事件一定会经过 Activity 吗？</h3><p>不是的。我们的程序界面的顶层 ViewGroup，也就是 DecorView 中注册了 Activity 这个 Callback，所以当程序的主界面接收到事件之后会先交给 Activity。 但是，如果是另外的控件树，如 Dialog、PopupWindow 等事件流是不会经过 Activity 的。只有自己界面的事件才会经 Activity。</p>
<h3 id="Activity的分发方法中调用了-onUserInteraction-方法，你能说说这个方法有什么作用吗？"><a href="#Activity的分发方法中调用了-onUserInteraction-方法，你能说说这个方法有什么作用吗？" class="headerlink" title="Activity的分发方法中调用了 onUserInteraction() 方法，你能说说这个方法有什么作用吗？"></a>Activity的分发方法中调用了 <code>onUserInteraction()</code> 方法，你能说说这个方法有什么作用吗？</h3><p>这个方法在 Activity 接收到 ACTION_DOWN 事件的时候会被调用，本身是个空方法，需要开发者自己去重写。 通过官方的注释可以知道，这个方法会在我们以任意的方式<strong>开始</strong>与 Activity 进行交互的时候被调用。</p>
<p>比较常见的场景就是屏保：当我们一段时间没有操作会显示一张图片，当我们开始与 Activity 交互的时候可在这个方法中取消屏保；另外还有没有操作自动隐藏工具栏，可以在这个方法中让工具栏重新显示。</p>
<h3 id="ViewGroup-是如何分发事件的？"><a href="#ViewGroup-是如何分发事件的？" class="headerlink" title="ViewGroup 是如何分发事件的？"></a>ViewGroup 是如何分发事件的？</h3><p>ViewGroup 处理事件信息分为三个步骤：拦截、寻找子控件、派发事件。</p>
<p>事件分发中有一个重要的规则：一个触控点的一个事件序列只能给一个 View 处理，除非异常情况。所以如果 ViewGroup 消费了 ACTION_DOWN 事件，那么子 View 将无法收到任何事件。</p>
<p>ViewGroup 第一步会判读这个事件是否需要分发给子 View，如果是则调用 <code>onInterceptTouchEvent()</code> 方法判断是否要进行拦截。 第二步是如果这个事件是 ACTION_DOWN 事件，那么需要为他寻找一个消费此事件的子控件，如果找到则为他创建一个 TouchTarget。 第三步是派发事件，如果存在 TouchTarget，说明找到了消费事件序列的子 View，直接分发给他，如果没有则交给自己处理。</p>
<h3 id="你前面讲到“一个触控点的一个事件序列只能给一个-View-处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？"><a href="#你前面讲到“一个触控点的一个事件序列只能给一个-View-处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？" class="headerlink" title="你前面讲到“一个触控点的一个事件序列只能给一个 View 处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？"></a>你前面讲到“一个触控点的一个事件序列只能给一个 View 处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？</h3><p>这里的异常情况主要有两点：</p>
<ol>
<li>被 ViewGroup 拦截</li>
<li>出现界面跳转等其他情况</li>
</ol>
<p>当事件流中断时，ViewGroup 会发送一个 ACTION_CANCEL 事件给到 View，此时需要做一些状态的恢复工作，如终止动画，恢复 View 大小等等。</p>
<h3 id="事件类型有哪些？"><a href="#事件类型有哪些？" class="headerlink" title="事件类型有哪些？"></a>事件类型有哪些？</h3><ul>
<li>ACTION_DOWN：手指接触时产生的事件。</li>
<li>ACTION_MOVE：手指在屏幕上滑动时产生此事件。</li>
<li>ACTION_UP：手指抬起时产生此事件。</li>
<li>ACTION_CANCEL：取消事件。</li>
<li>ACTION_POINTER_DOWN：当已经有一个手指按下的情况下，另一个手指按下会产生该事件。</li>
<li>ACTION_POINTER_UP：多个手指同时按下的情况下，抬起其中一个手指会产生该事件。</li>
</ul>
<h3 id="你知道-ViewGroup-是如何将多个手指产生的事件准确分发给不同的子-View-吗？"><a href="#你知道-ViewGroup-是如何将多个手指产生的事件准确分发给不同的子-View-吗？" class="headerlink" title="你知道 ViewGroup 是如何将多个手指产生的事件准确分发给不同的子 View 吗？"></a>你知道 ViewGroup 是如何将多个手指产生的事件准确分发给不同的子 View 吗？</h3><p>这个问题的关键在于 MotionEvent 以及 ViewGroup 内部的 TouchTarget。</p>
<p>每个 MotionEvent 中都包含了当前屏幕所有触控点的信息，他的内部用了一个数组来存储不同的触控 id 所对应的坐标数值。</p>
<p>当一个子 View 消费了 ACTION_DOWN 事件之后，ViewGroup 会为该 View 创建一个 TouchTarget，这个TouchTarget 就包含了该 View 的实例与触控 id。这里的触控 id 可以是多个，也就是一个 View 可接受多个触控点的事件序列。</p>
<p>当一个 MotionEvent 到来之时，ViewGroup 会将其中的触控点信息拆开，再分别发送给感兴趣的子 View。从而达到精准发送触控点信息的目的。</p>
<h3 id="那-View-支持处理多指信息吗？"><a href="#那-View-支持处理多指信息吗？" class="headerlink" title="那 View 支持处理多指信息吗？"></a>那 View 支持处理多指信息吗？</h3><p>View 默认是不支持的。他在获取触控点信息的时候并没有传入触控点索引，也就是获取的是 MotionEvent 内部数组中的第一个触控点的信息。多指需要我们自己去重写方法支持他。</p>
<h3 id="View-是如何处理触摸事件的？"><a href="#View-是如何处理触摸事件的？" class="headerlink" title="View 是如何处理触摸事件的？"></a>View 是如何处理触摸事件的？</h3><p>首先，他会判断是否存在 <code>onTouchListener()</code>，存在则会调用他的 <code>onTouch()</code> 方法来处理事件。如果该方法返回 <code>true </code> 那么就分发结束直接返回。而如果该监听器为 <code>null</code> 或者 <code> onTouch()</code> 方法返回了 <code>false</code>，则会调用 <code>onTouchEvent()</code> 方法来处理事件。</p>
<p><code>onTouchEvent()</code> 方法中支持了两种监听器：<code>onClickListener ()</code> 和 <code>onLongClickListener()</code>。View 会根据不同的触摸情况来调用这两个监听器。同时进入到 <code>onTouchEvent()</code> 方法中，无论该 View 是否是 <code>enable</code>，只要是 <code>clickable</code>，他的分发方法都是返回 <code>true</code>。</p>
<p>总结一下就是：先调用 <code>onTouchListener()</code>，再调用 <code>onClickListener()</code> 和 <code>onLongClickListener()</code>。</p>
<h3 id="在实际中有运用到事件分发吗？"><a href="#在实际中有运用到事件分发吗？" class="headerlink" title="在实际中有运用到事件分发吗？"></a>在实际中有运用到事件分发吗？</h3><ol>
<li><p>第一个需求是要设计一个按钮块，按下的时候会缩小高度变低同时变得半透明，放开的时候又会回弹。这个时候就可以在这个按钮的 <code>onTouchEvent()</code> 方法中判断事件类型：down 则开启按下动画，up 则开启释放动画。同时注意接收到 cancel 事件的时候要恢复状态。</p>
</li>
<li><p>第二个是滑动冲突。</p>
<p>解决滑动冲突的核心思路就是把滑动事件根据具体的情况分发给 ViewGroup 或者内部 View。主要的方法有外部拦截法和内部拦截法。 </p>
<ul>
<li>外部拦截法的思路就是在 ViewGroup 中判断滑动的情况，对符合自身滑动的事件进行拦截，对不符合的事件不拦截，给到内部 View。</li>
<li>内部拦截法的思路要求 ViewGroup 拦截除了 down 事件以外的所有事件，然后再内部 View 中判断滑动的情况，对符合自身滑动情况的时间设置禁止拦截标志，对不符合自身滑动情况的事件则取消标志让 ViewGroup 进行拦截。</li>
</ul>
</li>
<li><p>那外部和内部拦截法该如何选择呢？</p>
<p>在一般的情况下，外部拦截法不需要对子 View 进行方法重写，比内部拦截法更加简单，推荐使用外部拦截法。</p>
<p>但如果需要在子 View 判断更多的触摸情况时，则使用内部拦截法可更加方法子 View 处理情况。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2015/09/19/android-touch/">http://gityuan.com/2015/09/19/android-touch/</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922300686638153736">https://juejin.cn/post/6922300686638153736</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Android/">Android</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="link-muted mr-2" rel="tag" href="/tags/View/">View</a><a class="link-muted mr-2" rel="tag" href="/tags/Window/">Window</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/12/14/android-window/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android Window 机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/13/%E4%B8%8A%E4%BC%A0-Android-%E5%BA%93%E5%88%B0-MavenCentral/"><span class="level-item">上传 Android 库到 MavenCentral</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "d937d9786d0c6691701ac23ce1cfea71",
            repo: "qihuan92.github.io",
            owner: "qihuan92",
            clientID: "63af65c81b81a45c85dd",
            clientSecret: "f332d0d8c42fecaf6ad773673656cf9bb39ccc70",
            admin: ["qihuan92"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#事件类型"><span class="level-left"><span class="level-item">1</span><span class="level-item">事件类型</span></span></a></li><li><a class="level is-mobile" href="#核心方法"><span class="level-left"><span class="level-item">2</span><span class="level-item">核心方法</span></span></a></li><li><a class="level is-mobile" href="#分发流程"><span class="level-left"><span class="level-item">3</span><span class="level-item">分发流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DecorView-dispatchTouchEvent"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">DecorView.dispatchTouchEvent()</span></span></a></li><li><a class="level is-mobile" href="#Activity-dispatchTouchEvent"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Activity.dispatchTouchEvent()</span></span></a></li><li><a class="level is-mobile" href="#PhoneWindow-superDispatchTouchEvent"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">PhoneWindow.superDispatchTouchEvent()</span></span></a></li><li><a class="level is-mobile" href="#ViewGroup-dispatchTouchEvent"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">ViewGroup.dispatchTouchEvent()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dispatchTransformedTouchEvent"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">dispatchTransformedTouchEvent()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#View-dispatchTouchEvent"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">View.dispatchTouchEvent()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#面试题"><span class="level-left"><span class="level-item">5</span><span class="level-item">面试题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事件一定会经过-Activity-吗？"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">事件一定会经过 Activity 吗？</span></span></a></li><li><a class="level is-mobile" href="#Activity的分发方法中调用了-onUserInteraction-方法，你能说说这个方法有什么作用吗？"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Activity的分发方法中调用了 onUserInteraction() 方法，你能说说这个方法有什么作用吗？</span></span></a></li><li><a class="level is-mobile" href="#ViewGroup-是如何分发事件的？"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">ViewGroup 是如何分发事件的？</span></span></a></li><li><a class="level is-mobile" href="#你前面讲到“一个触控点的一个事件序列只能给一个-View-处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">你前面讲到“一个触控点的一个事件序列只能给一个 View 处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？</span></span></a></li><li><a class="level is-mobile" href="#事件类型有哪些？"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">事件类型有哪些？</span></span></a></li><li><a class="level is-mobile" href="#你知道-ViewGroup-是如何将多个手指产生的事件准确分发给不同的子-View-吗？"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">你知道 ViewGroup 是如何将多个手指产生的事件准确分发给不同的子 View 吗？</span></span></a></li><li><a class="level is-mobile" href="#那-View-支持处理多指信息吗？"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">那 View 支持处理多指信息吗？</span></span></a></li><li><a class="level is-mobile" href="#View-是如何处理触摸事件的？"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">View 是如何处理触摸事件的？</span></span></a></li><li><a class="level is-mobile" href="#在实际中有运用到事件分发吗？"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">在实际中有运用到事件分发吗？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">6</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-07T08:49:54.000Z">2022-11-07</time></p><p class="title"><a href="/2022/11/07/android-apt-activity-starter/">从 startActivity 谈谈 APT 的应用</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-31T01:48:05.000Z">2021-12-31</time></p><p class="title"><a href="/2021/12/31/iterm-shortcut-key/">iTerm 快捷键速查</a></p><p class="categories"><a href="/categories/%E7%BB%88%E7%AB%AF/">终端</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-27T08:55:36.000Z">2021-12-27</time></p><p class="title"><a href="/2021/12/27/android-handler/">Android Handler 原理分析</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-22T09:05:48.000Z">2021-12-22</time></p><p class="title"><a href="/2021/12/22/android-ams/">Android AMS 原理解读</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-14T09:07:51.000Z">2021-12-14</time></p><p class="title"><a href="/2021/12/14/android-window/">Android Window 机制</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">QiHuan</a><p class="is-size-7"><span>&copy; 2024 齐欢</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/qihuan92"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>