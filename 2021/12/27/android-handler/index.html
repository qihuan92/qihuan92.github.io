<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android Handler 原理分析 - 齐欢的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="齐欢的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="齐欢的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Handler 是 Android 应用非常重要的组成部分，它的身影可谓是无处不在了，从系统源码到第三方库，再到我们开发的过程中都离不开 Handler。许多开发中的问题也涉及到 Handler 相关的知识，例如 ANR 问题、UI 的绘制以及线程的调度等，本文将从源码分析、常见问题以及 Handler 的一些应用等方面进行分析。"><meta property="og:type" content="blog"><meta property="og:title" content="Android Handler 原理分析"><meta property="og:url" content="https://qihuan92.github.io/2021/12/27/android-handler/"><meta property="og:site_name" content="齐欢的博客"><meta property="og:description" content="Handler 是 Android 应用非常重要的组成部分，它的身影可谓是无处不在了，从系统源码到第三方库，再到我们开发的过程中都离不开 Handler。许多开发中的问题也涉及到 Handler 相关的知识，例如 ANR 问题、UI 的绘制以及线程的调度等，本文将从源码分析、常见问题以及 Handler 的一些应用等方面进行分析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.unsplash.com/photo-1583193123517-09ef9447412c?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;ixid=eyJhcHBfaWQiOjYzOTIxfQ&amp;w=4800"><meta property="article:published_time" content="2021-12-27T08:55:36.000Z"><meta property="article:modified_time" content="2024-02-05T02:26:43.114Z"><meta property="article:author" content="齐欢"><meta property="article:tag" content="Android"><meta property="article:tag" content="源码"><meta property="article:tag" content="Handler"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://images.unsplash.com/photo-1583193123517-09ef9447412c?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;ixid=eyJhcHBfaWQiOjYzOTIxfQ&amp;w=4800"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://qihuan92.github.io/2021/12/27/android-handler/"},"headline":"Android Handler 原理分析","image":[],"datePublished":"2021-12-27T08:55:36.000Z","dateModified":"2024-02-05T02:26:43.114Z","author":{"@type":"Person","name":"齐欢"},"publisher":{"@type":"Organization","name":"齐欢的博客","logo":{"@type":"ImageObject","url":{"text":"QiHuan"}}},"description":"Handler 是 Android 应用非常重要的组成部分，它的身影可谓是无处不在了，从系统源码到第三方库，再到我们开发的过程中都离不开 Handler。许多开发中的问题也涉及到 Handler 相关的知识，例如 ANR 问题、UI 的绘制以及线程的调度等，本文将从源码分析、常见问题以及 Handler 的一些应用等方面进行分析。"}</script><link rel="canonical" href="https://qihuan92.github.io/2021/12/27/android-handler/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">QiHuan</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/qihuan92"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://images.unsplash.com/photo-1583193123517-09ef9447412c?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb&amp;ixid=eyJhcHBfaWQiOjYzOTIxfQ&amp;w=4800" alt="Android Handler 原理分析"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-27T08:55:36.000Z" title="2021/12/27 16:55:36">2021-12-27</time>发表</span><span class="level-item"><time dateTime="2024-02-05T02:26:43.114Z" title="2024/2/5 10:26:43">2024-02-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">34 分钟读完 (大约5169个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Android Handler 原理分析</h1><div class="content"><p>Handler 是 Android 应用非常重要的组成部分，它的身影可谓是无处不在了，从系统源码到第三方库，再到我们开发的过程中都离不开 Handler。许多开发中的问题也涉及到 Handler 相关的知识，例如 ANR 问题、UI 的绘制以及线程的调度等，本文将从源码分析、常见问题以及 Handler 的一些应用等方面进行分析。</p>
<span id="more"></span>

<h2 id="Handler-原理分析"><a href="#Handler-原理分析" class="headerlink" title="Handler 原理分析"></a>Handler 原理分析</h2><h3 id="什么是-Handler"><a href="#什么是-Handler" class="headerlink" title="什么是 Handler"></a>什么是 Handler</h3><p>下边是<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/os/Handler">官网</a>对于 Handler 的定义</p>
<blockquote>
<p><em>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper. It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread.</em></p>
</blockquote>
<p>其大概意思就是说，Handler 可以发送 Message 或 Runnable 到消息队列（MessageQueue）中，每一个 Handler 实例和一个线程及这个线程的消息队列相关联。创建一个 Handler 实例时需要和一个 Looper 进行绑定，它向这个 Looper 所在的线程的消息队列发送消息，并在当前的线程处理这些消息。</p>
<h3 id="Handler-工作流程"><a href="#Handler-工作流程" class="headerlink" title="Handler 工作流程"></a>Handler 工作流程</h3><p>Handler 的工作流程如下图所示：<br><img src="https://raw.githubusercontent.com/qihuan92/figurebed/master/20211227175917.jpg" alt="Handler 工作流程"><br>我们可以看出，Looper 为消息队列提供动力，不断地循环消息队列中的消息，Handler 向消息队列发送消息并处理消息。<br>Handler 关键方法调用如下所示：<br><img src="https://raw.githubusercontent.com/qihuan92/figurebed/master/20211230163338.jpg" alt="Handler 关键方法"></p>
<h3 id="Android-主线程中的-Handler"><a href="#Android-主线程中的-Handler" class="headerlink" title="Android 主线程中的 Handler"></a>Android 主线程中的 Handler</h3><p>从<a href="#%E4%BB%80%E4%B9%88%E6%98%AF-Handler">官网定义</a>中，我们得知创建一个 Handler 实例时需要和一个 Looper 进行绑定，那么我们在平常使用 Handler 时并没有接触过 Looper 这个东西，这是因为在主线程创建 Handler 之前，Android 已经创建了一个 Looper 并开启了循环。我们可以看下应用的入口 <code>ActivityThread.main()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 创建 Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程 Handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Looper 开启循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h4><p>首先调用了 <code>Looper.prepareMainLooper()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Looper</span> &#123;</span><br><span class="line">    <span class="comment">// 这里创建一个 ThreadLocal 用来存放 Looper，保证一个线程都有一个自己的 Looper</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        prepare(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 Looper 已经初始化，则不可以再次创建</span></span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个 Looper，并放到 ThreadLocal 中</span></span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Looper.prepareMainLooper()</code> 方法中又调用了 <code>prepare()</code> 方法，这个方法会创建一个 Looper，然后<a href="#%E5%85%B3%E4%BA%8E-ThreadLocal">将这个 Looper 放到一个 ThreadLocal 中</a>，并且在之前还进行了防止重复的校验。也就是说一个线程都有自己单独的 Looper，且只能创建一次。</p>
<p>然后再跟进到 Looper 的构造方法看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Looper.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper 在创建的时候也创建了消息队列，也就是说每一个线程中只能有一个 Looper 和 MessageQueue。</p>
<h4 id="ActivityThread-H"><a href="#ActivityThread-H" class="headerlink" title="ActivityThread.H"></a>ActivityThread.H</h4><p>我们再来看一下 ActivityThread 中的 <code>sMainThreadHandler = thread.getHandler();</code> 这行代码，<code>thread.getHandler()</code> 实际上是获取的 ActivityThread 中的内部类 mH，这个 Handler 负责处理四大组件以及 Application 的一些消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                handleBindApplication(data);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mInitialApplication.onTerminate();</span><br><span class="line">                &#125;</span><br><span class="line">                Looper.myLooper().quit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;broadcastReceiveComp&quot;</span>);</span><br><span class="line">                handleReceiver((ReceiverData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceBind&quot;</span>);</span><br><span class="line">                handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNBIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceUnbind&quot;</span>);</span><br><span class="line">                handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceStart: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceStop&quot;</span>);</span><br><span class="line">                handleStopService((IBinder)msg.obj);</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">case</span> APPLICATION_INFO_CHANGED:</span><br><span class="line">                mUpdatingSystemConfig = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    handleApplicationInfoChanged((ApplicationInfo) msg.obj);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mUpdatingSystemConfig = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUN_ISOLATED_ENTRY_POINT:</span><br><span class="line">                handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                        (String[]) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> (ClientTransaction) msg.obj;</span><br><span class="line">                mTransactionExecutor.execute(transaction);</span><br><span class="line">                <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                    <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">                    <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">                    <span class="comment">// message is handled.</span></span><br><span class="line">                    transaction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELAUNCH_ACTIVITY:</span><br><span class="line">                handleRelaunchActivityLocally((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PURGE_RESOURCES:</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h4><p>最后我们再看一下 <code>Looper.loop()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Looper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取ThreadLocal中的Looper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 回收复用  </span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loop</code> 方法中是一个死循环，在这里从消息队列中不断的获取消息 <code>queue.next()</code>，然后通过 <code>Handler.dispatchMessage()</code> 进行消息的分发，<strong>其实并没有什么具体的绑定，因为 Handler 在每个线程中对应只有一个 Looper 和消息队列 MessageQueue，自然要靠它来处理，也就是是调用 <code>Looper.loop()</code> 方法</strong>。在 <code>Looper.loop()</code> 的死循环中不断的取消息，最后回收复用。</p>
<p><strong>这里注意 Message 中的 target（Handler） 这个成员变量，正是有了这个变量，每个 Message 才能找到它所对应的 Handler，让多个 Handler 同时工作处理各自的消息</strong></p>
<p>注意：在创建 Message 时，应该使用 <code>Message.obtain()</code> 方法创建，这样所有的消息会被回收，放入 sPool 中，使用享元设计模式。</p>
<h4 id="Looper-死循环会消耗大量的资源吗？"><a href="#Looper-死循环会消耗大量的资源吗？" class="headerlink" title="Looper 死循环会消耗大量的资源吗？"></a>Looper 死循环会消耗大量的资源吗？</h4><p>关键就在 <code>queue.next()</code> 消息队列取消息的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MessageQueue.java</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// Linux pipe/epoll 机制，在没有消息的时候阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取开机到现在的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">// 没到执行时间，计算等待时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MessageQueue.next()</code> 方法中，会调用 <code>nativePollOnce()</code> 本地方法，这里会利用 Linux 的 pipe&#x2F;epoll 机制，在没有消息的时候阻塞在这里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。<br>这里采用的 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪（读或写就绪），则立刻通知相应程序进行读或写操作，本质同步 I&#x2F;O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。<br>关于 Linux 的 pipe&#x2F;epoll 机制，可移步<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dfd940e7fca2">此文</a>。</p>
<h5 id="nativePollOnce"><a href="#nativePollOnce" class="headerlink" title="nativePollOnce()"></a>nativePollOnce()</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_MessageQueue_nativeIsPolling</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">isPolling</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">Throw</span>(mExceptionObj);</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Looper.cpp</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 利用 epoll_wait() 进行阻塞等待</span></span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主线程的-Handler-的退出"><a href="#主线程的-Handler-的退出" class="headerlink" title="主线程的 Handler 的退出"></a>主线程的 Handler 的退出</h4><p>在 App 退出时，ActivityThread 中的 mH（Handler）收到消息后，执行退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.H.handleMessage()</span></span><br><span class="line"><span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">    <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInitialApplication.onTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.myLooper().quit();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>注意：当我们尝试手动退出时会抛出如下异常，这是因为主线程不允许退出，一旦退出就意味着程序挂了，退出也不应该用这种方式退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br></pre></td></tr></table></figure>

<h2 id="关于-ThreadLocal"><a href="#关于-ThreadLocal" class="headerlink" title="关于 ThreadLocal"></a>关于 ThreadLocal</h2><p>从 Looper 的源码中，我们可以看到创建 Looper 实例后，将它放到了 ThreadLocal 中，以保证线程中各自都有一个 Looper 实例。<br>ThreadLocal 为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<h3 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h3><p>Java 的实现里面有一个 Map，叫做 ThreadLocalMap，持有 ThreadLocalMap 的是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="comment">// 内部持有 ThreadLocalMap</span></span><br><span class="line">  ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先获取线程持有的 ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> Thread.currentThread().threadLocals;</span><br><span class="line">        <span class="comment">// 在 ThreadLocalMap 中查找变量</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// 内部是数组而不是 Map</span></span><br><span class="line">    Entry[] table;</span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 查找 Entry</span></span><br><span class="line">    Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal key)</span>&#123;</span><br><span class="line">      <span class="comment">//...查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Entry </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&gt;&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 的实现方案中，ThreadLocal 仅仅只是一个代理工具类，内部并不持有任何线程相关的数据，所有和线程相关的数据都存储在 Thread 里面，这样的设计从数据的亲缘性上来讲，ThreadLocalMap 属于 Thread 也更加合理。所以 ThreadLocal 的 <code>get()</code> 方法，其实就是拿到每个线程独有的 ThreadLocalMap。<br>这种设计方案的好处就是<strong>不容易产生内存泄漏</strong>，如果在 ThreadLocal 用一个键为 Thread 值为存储的内容的 Map 这种设计方案，ThreadLocal 持有的 Map 会持有 Thread 对象的引用，这就意味着只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往都比线程要长，所以这种设计方案很容易导致内存泄漏。而 Java 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用，所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。Java 的实现方案虽然看上去复杂一些，但是更安全。</p>
<h3 id="ThreadLocal-与内存泄漏"><a href="#ThreadLocal-与内存泄漏" class="headerlink" title="ThreadLocal 与内存泄漏"></a>ThreadLocal 与内存泄漏</h3><p>但是如果在线程池中使用 ThreadLocal 可能会导致内存泄漏，原因是线程池中线程的存活时间太长，往往和程序都是同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用，所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄漏。<br>我们可以通过 <code>try&#123;&#125; finally&#123;&#125;</code> 方案来手动释放资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Handler-的同步屏障机制"><a href="#Handler-的同步屏障机制" class="headerlink" title="Handler 的同步屏障机制"></a>Handler 的同步屏障机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Handler 加入了<strong>同步屏障机制</strong>，来实现<em>异步消息优先执行</em>的功能。<br>Handler 通过 <code>MessageQueue.postSyncBarrier()</code> 发送同步屏障，<code>MessageQueue.removeSyncBarrier()</code> 移除同步屏障。</p>
<p>同步屏障的作用可以理解成<strong>拦截同步消息</strong>的执行，主线程的 Looper 会一直循环调用 <code>MessageQueue.next()</code> 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。当 <code>next()</code> 方法在取 Message 时发现<strong>队头是一个同步屏障的消息时</strong>，就会去遍历整个队列，<strong>只寻找设置了异步标志的消息</strong>，如果有找到异步消息，那么就<strong>取出这个异步消息来执行</strong>，否则就让 <code>next()</code> 方法陷入阻塞状态。如果 <code>next()</code> 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，不处理消息。总的来说就是队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除出队列，否则主线程就一直不会去处理同步屏幕后面的同步消息。而所有消息默认都是同步消息，只有手动设置了异步标志，这个消息才会是异步消息。但是同步屏障消息只能由 Android 内部来发送，这个接口不提供给应用开发者使用。</p>
<h3 id="Choreographer-与同步屏障机制"><a href="#Choreographer-与同步屏障机制" class="headerlink" title="Choreographer 与同步屏障机制"></a>Choreographer 与同步屏障机制</h3><p>Choreographer 里所有跟 message 有关的代码，<strong>都设置了异步消息的标志</strong>，所以这些操作是不受到同步屏障影响的。这样做的原因可能就是为了尽可能保证在接收到屏幕刷新信号时，可以在第一时间执行遍历绘制 View 树的工作（<code>doTraversal()</code>），在绘制工作的时候，如果有其他同步消息都要等到 <code>doTraversal()</code> 之后来避免掉帧现象。<br>那么，有了同步屏障消息的控制就能保证每次一接收到屏幕刷新信号就第一时间处理遍历绘制 View 树的工作么？<br>答案是不一定的，因为同步屏障是在 <code>scheduleTraversals()</code> 方法被调用时才发送到消息队列里的，也就是说，只有当某个 View 发起了刷新请求时，在这个时刻后面的同步消息才会被拦截掉，而在 <code>scheduleTraversals()</code> 之前就发送到消息队列里的工作仍然会按顺序依次被取出来执行。<br>关于屏幕刷新机制可参考<a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/6524387019">这篇文章</a>。</p>
<h3 id="如何监听应用的帧率？"><a href="#如何监听应用的帧率？" class="headerlink" title="如何监听应用的帧率？"></a>如何监听应用的帧率？</h3><p>可通过 <code>Choreographer.getInstance().postFrameCallback()</code> 来监听帧率情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FPSFrameCallback</span> <span class="keyword">implements</span> <span class="title class_">Choreographer</span>.FrameCallback &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;FPS_TEST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mLastFrameTimeNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mFrameIntervalNanos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FPSFrameCallback</span><span class="params">(<span class="type">long</span> lastFrameTimeNanos)</span> &#123;</span><br><span class="line">        mLastFrameTimeNanos = lastFrameTimeNanos;</span><br><span class="line">        <span class="comment">// 每一帧渲染时间（纳秒）</span></span><br><span class="line">        mFrameIntervalNanos = (<span class="type">long</span>) (<span class="number">1000000000</span> / <span class="number">60.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123; <span class="comment">// frameTimeNanos 为 Vsync 信号到来的时间 </span></span><br><span class="line">        <span class="comment">// 初始化时间</span></span><br><span class="line">        <span class="keyword">if</span> (mLastFrameTimeNanos == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一帧的渲染时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                    + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        <span class="comment">// 注册下一帧回调</span></span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Application 中注册 FPSFrameCallback：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(FPSFrameCallback(System.nanoTime()))</span><br></pre></td></tr></table></figure>

<h2 id="Handler-中的锁"><a href="#Handler-中的锁" class="headerlink" title="Handler 中的锁"></a>Handler 中的锁</h2><p>在不同的线程都可以使用 Handler 来发送消息，那么它是怎么保证线程安全的呢？<br>Handler 通过 <code>Handler.sendMessage()</code>、<code>Handler.post()</code> 等方法发送消息，会调到 <code>MessageQueue.enqueueMessage()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MessageQueue.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部通过 <code>synchronized</code> 关键字保证线程安全，<a href="#Looper-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BC%9A%E6%B6%88%E8%80%97%E5%A4%A7%E9%87%8F%E7%9A%84%E8%B5%84%E6%BA%90%E5%90%97%EF%BC%9F">同时 <code>MessageQueue.next()</code> 内部也会通过 <code>synchronized</code> 加锁，确保取的时候线程安全，同时插入也会加锁。</a> <code>MessageQueue.next()</code> 方法中的 <code>synchronized</code> 为 <code>this</code> 加锁，意思是为 MessageQueue 对象加锁。<br>关于锁的机制会在其他文章展开。(TODO)</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Handler-是如何进行线程切换的？"><a href="#Handler-是如何进行线程切换的？" class="headerlink" title="Handler 是如何进行线程切换的？"></a>Handler 是如何进行线程切换的？</h3><p>原理很简单，线程间是共享资源的，子线程通过 <code>Handler.sendMessage()</code>、<code>Handler.post()</code> 等方法发送消息，然后通过 <code>Looper.loop()</code> 在消息队列中不断的循环检索消息，最后交给 <code>Handler.dispatchMessage()</code> 方法进行消息的分发处理。</p>
<h3 id="Handler-为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如-Adapter-中的-ViewHolder。"><a href="#Handler-为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如-Adapter-中的-ViewHolder。" class="headerlink" title="Handler 为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如 Adapter 中的 ViewHolder。"></a>Handler 为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如 Adapter 中的 ViewHolder。</h3><p>当在 Activity 中创建非静态的 Handler 类时，这个 Handler 为 Activity 的匿名内部类，当它调用 Activity 的方法时，Handler 是持有 Activity 的，导致 Activity 无法回收。<br>Adapter 中的 ViewHolder 没有内存泄漏的原因是因为 ViewHolder 的生命周期比 Adapter 短。但是 Handler 的生命周期可能比 Activity 的生命周期长，比如延时发送消息的情况。</p>
<h3 id="如何在子线程中创建-Handler？"><a href="#如何在子线程中创建-Handler？" class="headerlink" title="如何在子线程中创建 Handler？"></a>如何在子线程中创建 Handler？</h3><p>因为在子线程中是不存在 Looper 的，所以先要创建一个 Looper，也就是调用 <code>Looper.prepare()</code> 方法，并调用 <code>Looper.loop()</code> 方法，使 Looper 运转起来，这样子线程的 Handler 才能正常使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Looper，MessageQueue</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>().post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 处理一些逻辑...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开始处理消息</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>这里需要注意在所有事情处理完成后应该调用 <code>quit()</code> 方法来终止消息循环，否则这个子线程就会一直处于循环等待的状态，因此不需要的时候终止 Looper，调用 <code>Looper.myLooper().quit()</code>。</p>
<h3 id="如何在主线程中访问网络？"><a href="#如何在主线程中访问网络？" class="headerlink" title="如何在主线程中访问网络？"></a>如何在主线程中访问网络？</h3><p>在网络请求之前添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrictMode</span>.ThreadPolicy.Builder().permitNetwork().build();</span><br><span class="line">StrictMode.setThreadPolicy(policy);</span><br></pre></td></tr></table></figure>
<p>StrictMode（严苛模式）Android2.3 引入，用于检测两大问题：ThreadPolicy（线程策略）和VmPolicy(VM策略)，这里把严苛模式的网络检测关了，就可以在主线程中执行网络操作了，一般是不建议这么做的。关于严苛模式可以查看<a target="_blank" rel="noopener" href="https://ericchows.github.io/Android-StrictMode-Analysis/">这里</a>。</p>
<h3 id="系统为什么不建议在子线程中访问-UI？"><a href="#系统为什么不建议在子线程中访问-UI？" class="headerlink" title="系统为什么不建议在子线程中访问 UI？"></a>系统为什么不建议在子线程中访问 UI？</h3><p>这是因为 Android 的 UI 控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，那么为什么系统不对 UI 控件的访问加上锁机制呢？缺点有两个：</p>
<ol>
<li>首先加上锁机制会让 UI 访问的逻辑变得复杂。</li>
<li>锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</li>
</ol>
<h3 id="子线程如何通知主线程更新-UI"><a href="#子线程如何通知主线程更新-UI" class="headerlink" title="子线程如何通知主线程更新 UI?"></a>子线程如何通知主线程更新 UI?</h3><ol>
<li>主线程中定义 Handler，子线程通过 mHandler 发送消息，主线程 Handler 的 handleMessage 更新 UI。</li>
<li>用 Activity 对象的 runOnUiThread 方法。</li>
<li>创建 Handler，传入 <code>getMainLooper()</code>。</li>
<li><code>View.post(Runnable r)</code> 。</li>
</ol>
<h3 id="Looper-死循环为什么不会导致应用卡死，会耗费大量资源吗？"><a href="#Looper-死循环为什么不会导致应用卡死，会耗费大量资源吗？" class="headerlink" title="Looper 死循环为什么不会导致应用卡死，会耗费大量资源吗？"></a>Looper 死循环为什么不会导致应用卡死，会耗费大量资源吗？</h3><p>Looper 并非简单地死循环，无消息时会休眠。<strong>Android 是基于消息处理机制的，用户的行为都在这个 Looper 循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作</strong>。<a href="#Looper-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BC%9A%E6%B6%88%E8%80%97%E5%A4%A7%E9%87%8F%E7%9A%84%E8%B5%84%E6%BA%90%E5%90%97%EF%BC%9F"><code>-&gt;</code></a></p>
<h3 id="如何处理-Handler-使用不当造成的内存泄漏？"><a href="#如何处理-Handler-使用不当造成的内存泄漏？" class="headerlink" title="如何处理 Handler 使用不当造成的内存泄漏？"></a>如何处理 Handler 使用不当造成的内存泄漏？</h3><ol>
<li>有延时消息，在界面关闭后及时移除 Message&#x2F;Runnable，调用 <code>handler.removeCallbacksAndMessages(null)</code></li>
<li>内部类导致的内存泄漏改为静态内部类，并对上下文或者 Activity&#x2F;Fragment 使用弱引用。</li>
</ol>
<p>如果有个延时消息，当界面关闭时，该 Handler 中的消息还没有处理完毕，那么最终这个消息是怎么处理的？比如打开界面后延迟 10s 发送消息，关闭界面，最终在 Handler（匿名内部类创建的）的 <code>handleMessage()</code> 方法中还是会收到消息。因为会有一条 MessageQueue -&gt; Message -&gt; Handler -&gt; Activity 的引用链，所以 Handler 不会被销毁，Activity 也不会被销毁。</p>
<h3 id="丢帧的原因有哪些？"><a href="#丢帧的原因有哪些？" class="headerlink" title="丢帧的原因有哪些？"></a>丢帧的原因有哪些？</h3><ol>
<li>遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms。</li>
<li>主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。</li>
</ol>
<h2 id="手写一个简版的-Handler"><a href="#手写一个简版的-Handler" class="headerlink" title="手写一个简版的 Handler"></a>手写一个简版的 Handler</h2><p><a target="_blank" rel="noopener" href="https://github.com/qihuan92/Playground/tree/master/handler">https://github.com/qihuan92/Playground/tree/master/handler</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Android/">Android</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="link-muted mr-2" rel="tag" href="/tags/Handler/">Handler</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/12/31/iterm-shortcut-key/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">iTerm 快捷键速查</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/12/22/android-ams/"><span class="level-item">Android AMS 原理解读</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "e265b377164629939a49375d5b5881eb",
            repo: "qihuan92.github.io",
            owner: "qihuan92",
            clientID: "63af65c81b81a45c85dd",
            clientSecret: "f332d0d8c42fecaf6ad773673656cf9bb39ccc70",
            admin: ["qihuan92"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Handler-原理分析"><span class="level-left"><span class="level-item">1</span><span class="level-item">Handler 原理分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Handler"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">什么是 Handler</span></span></a></li><li><a class="level is-mobile" href="#Handler-工作流程"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Handler 工作流程</span></span></a></li><li><a class="level is-mobile" href="#Android-主线程中的-Handler"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Android 主线程中的 Handler</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Looper-prepare"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">Looper.prepare()</span></span></a></li><li><a class="level is-mobile" href="#ActivityThread-H"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">ActivityThread.H</span></span></a></li><li><a class="level is-mobile" href="#Looper-loop"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">Looper.loop()</span></span></a></li><li><a class="level is-mobile" href="#Looper-死循环会消耗大量的资源吗？"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">Looper 死循环会消耗大量的资源吗？</span></span></a></li><li><a class="level is-mobile" href="#主线程的-Handler-的退出"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">主线程的 Handler 的退出</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#关于-ThreadLocal"><span class="level-left"><span class="level-item">2</span><span class="level-item">关于 ThreadLocal</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ThreadLocal-原理"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">ThreadLocal 原理</span></span></a></li><li><a class="level is-mobile" href="#ThreadLocal-与内存泄漏"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">ThreadLocal 与内存泄漏</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Handler-的同步屏障机制"><span class="level-left"><span class="level-item">3</span><span class="level-item">Handler 的同步屏障机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#Choreographer-与同步屏障机制"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Choreographer 与同步屏障机制</span></span></a></li><li><a class="level is-mobile" href="#如何监听应用的帧率？"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">如何监听应用的帧率？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Handler-中的锁"><span class="level-left"><span class="level-item">4</span><span class="level-item">Handler 中的锁</span></span></a></li><li><a class="level is-mobile" href="#面试题"><span class="level-left"><span class="level-item">5</span><span class="level-item">面试题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Handler-是如何进行线程切换的？"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Handler 是如何进行线程切换的？</span></span></a></li><li><a class="level is-mobile" href="#Handler-为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如-Adapter-中的-ViewHolder。"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Handler 为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如 Adapter 中的 ViewHolder。</span></span></a></li><li><a class="level is-mobile" href="#如何在子线程中创建-Handler？"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">如何在子线程中创建 Handler？</span></span></a></li><li><a class="level is-mobile" href="#如何在主线程中访问网络？"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">如何在主线程中访问网络？</span></span></a></li><li><a class="level is-mobile" href="#系统为什么不建议在子线程中访问-UI？"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">系统为什么不建议在子线程中访问 UI？</span></span></a></li><li><a class="level is-mobile" href="#子线程如何通知主线程更新-UI"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">子线程如何通知主线程更新 UI?</span></span></a></li><li><a class="level is-mobile" href="#Looper-死循环为什么不会导致应用卡死，会耗费大量资源吗？"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">Looper 死循环为什么不会导致应用卡死，会耗费大量资源吗？</span></span></a></li><li><a class="level is-mobile" href="#如何处理-Handler-使用不当造成的内存泄漏？"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">如何处理 Handler 使用不当造成的内存泄漏？</span></span></a></li><li><a class="level is-mobile" href="#丢帧的原因有哪些？"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">丢帧的原因有哪些？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#手写一个简版的-Handler"><span class="level-left"><span class="level-item">6</span><span class="level-item">手写一个简版的 Handler</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-07T08:49:54.000Z">2022-11-07</time></p><p class="title"><a href="/2022/11/07/android-apt-activity-starter/">从 startActivity 谈谈 APT 的应用</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-31T01:48:05.000Z">2021-12-31</time></p><p class="title"><a href="/2021/12/31/iterm-shortcut-key/">iTerm 快捷键速查</a></p><p class="categories"><a href="/categories/%E7%BB%88%E7%AB%AF/">终端</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-27T08:55:36.000Z">2021-12-27</time></p><p class="title"><a href="/2021/12/27/android-handler/">Android Handler 原理分析</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-22T09:05:48.000Z">2021-12-22</time></p><p class="title"><a href="/2021/12/22/android-ams/">Android AMS 原理解读</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-14T09:07:51.000Z">2021-12-14</time></p><p class="title"><a href="/2021/12/14/android-window/">Android Window 机制</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">QiHuan</a><p class="is-size-7"><span>&copy; 2024 齐欢</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/qihuan92"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>