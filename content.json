{"posts":[{"title":"从 startActivity 谈谈 APT 的应用","text":"本文通过对 Activity 启动聊起，从这个小需求谈一谈注解处理器框架（APT）的应用。 背景在 Android 开发中，Activity 是页面的载体，由于我们还未完全使用单 Activity 这种开发架构，所以会有多个 Activity 分别来承载这些页面，这中间就会涉及到页面的跳转传值问题，我们一般会采用系统提供给我们的 startActivity() 来启动页面，通过传入 Intent 参数来处理页面的传值逻辑。 遇到的问题举个简单的例子，我们现在有一个详情页面 DetailActivity： public class DetailActivity extends AppCompatActivity { private long id; private String userId; private String title; // ...} 其中有三个参数，如果我们想跳转到这个 Activity 并传参，一般会按照这种方式： Intent intent = new Intent(this, DetailActivity.class);intent.putExtra(&quot;id&quot;, 123456L);intent.putExtra(&quot;userId&quot;, &quot;100008&quot;);intent.putExtra(&quot;title&quot;, &quot;测试&quot;);startActivity(intent); 然后 DetailActivity 需要按照这样的方式来获取参数： Intent intent = getIntent();id = intent.getLongExtra(&quot;id&quot;, 0L);userId = intent.getStringExtra(&quot;userId&quot;);title = intent.getStringExtra(&quot;title&quot;); 这里我们就会发现两个问题： 传值不安全 这几个变量我们分别定义了几个魔法值，如果我们想跳转到这个页面需要到详情页找到 getIntent() 调用的地方，并获取到这些 key 来传值，如果是两个开发人员分别负责这两个页面，极大的降低了开发效率以及增加了许多沟通成本。 当然在我们现在的开发中，这些 key 会在目的 Activity 定义为常量，来提高安全性，但是这样我们依然需要查看目标文件这些变量的定义。 逻辑分散 public class DetailActivity extends AppCompatActivity { public static final String EXTRA_ID = &quot;id&quot;; public static final String EXTRA_USER_ID = &quot;userId&quot;; public static final String EXTRA_TITLE = &quot;title&quot;; private long id; private String userId; private String title; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); Intent intent = getIntent(); id = intent.getLongExtra(EXTRA_ID, 0L); userId = intent.getStringExtra(EXTRA_USER_ID); title = intent.getStringExtra(EXTRA_TITLE); }} 从上边的代码可以看出，为了获取从外部传过来的参数，需要好几块代码来处理，如果增加和修改参数，都可能会导致改错或者漏改的情况，并且也需要告知调用者具体的改动，从而一定程度上增加了沟通成本。 优化方案针对于以上的两个问题，其实我们项目中已经很大程度上的处理了这个问题，来降低可维护以及沟通的成本，就是在目标 Activity 中添加一个 start() 静态函数，通过传入 Context 和页面参数来启动目标页面： public class DetailActivity extends AppCompatActivity { public static final String EXTRA_ID = &quot;id&quot;; public static final String EXTRA_USER_ID = &quot;userId&quot;; public static final String EXTRA_TITLE = &quot;title&quot;; private long id; private String userId; private String title; /** * Start DetailActivity. * * @param context context * @param id id * @param userId userID * @param title detail content */ public static void start(Context context, long id, String userId, String title) { Intent intent = new Intent(context, DetailActivity.class); intent.putExtra(EXTRA_ID, id); intent.putExtra(EXTRA_USER_ID, userId); intent.putExtra(EXTRA_TITLE, title); context.startActivity(intent); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); Intent intent = getIntent(); id = intent.getLongExtra(EXTRA_ID, 0L); userId = intent.getStringExtra(EXTRA_USER_ID); title = intent.getStringExtra(EXTRA_TITLE); }} 那么我们现在来对比一下调用者启动页面的代码： Intent intent = new Intent(this, DetailActivity.class);intent.putExtra(&quot;id&quot;, 123456L);intent.putExtra(&quot;userId&quot;, &quot;100008&quot;);intent.putExtra(&quot;title&quot;, &quot;测试标题&quot;);startActivity(intent);DetailActivity.start( this, 123456L, &quot;100008&quot;, &quot;测试标题&quot;); 解决的问题： 降低了调用者的调用成本，通过注释的方式也降低了沟通成本。 使传参和取参的逻辑聚合到了一个页面，提高了可维护性。 未解决的问题： 在目标 Activity 中获取参数逻辑分散的问题，如果新增或者修改字段甚至还要多修改一个地方。 需要自己写 start() 函数，比较繁琐。 再次思考经过以上优化后，我们还存在两个问题 参数获取问题 获取参数 → 给成员变量赋值 需要手动写 start() 静态函数 注入参数针对于第一点，其实我们可以将参数注入，可以看到一些框架早就有了解决方案，比如历史悠久的 ButterKnife： class ExampleActivity extends Activity { @BindView(R.id.user) EditText username; @BindView(R.id.pass) EditText password; @BindString(R.string.login_error) String loginErrorMessage; @OnClick(R.id.submit) void submit() { // TODO call server... } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this); // TODO Use fields... }} 还有路由框架 ARouter： // Declare a field for each parameter and annotate it with @Autowired@Route(path = &quot;/test/activity&quot;)public class Test1Activity extends Activity { @Autowired public String name; @Autowired int age; @Autowired(name = &quot;girl&quot;) // Map different parameters in the URL by name boolean boy; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // ARouter will automatically set value of fields Log.d(&quot;param&quot;, name + age + boy); }} 其实我们可以借鉴这两个框架，来实现我们的参数注入，代码大概就是下面这样： public class DetailActivity extends AppCompatActivity { @Extra long id; @Extra(description = &quot;用户ID&quot;) String userId; @Extra(required = false, description = &quot;详情内容&quot;) String title; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ActivityStarter.inject(this); }} 在参数上打上注解，方便注入对应的值， 可以选择必传参数和非必传参数 可以添加描述内容，方便生成注释 我们了解到这两个框架都是用到了注解处理器（APT，Annotation Processing Tool），这是一种处理注解的工具，确切的说它是 javac 的一个工具，它用来在编译时扫描和处理注解。注解处理器以 Java 代码(或者编译过的字节码)作为输入，生成 .java 文件作为输出。简单来说就是在编译期，通过注解生成**.java**文件。 那么获取参数部分的代码可以通过注解处理器来帮我们生成。 样板代码接下来就是第二个问题，其实我们发现每个页面的 start() 方法就是重复的样板代码，既然我们都用上了 APT，那么这个问题也就解决了，可以使用 APT 来帮助我们生成 start() 方法。 使用 APT 解决页面跳转传参问题 写出要生成的代码 首先我们需要写出 APT 帮我们生成的代码，以此做为模板，再通过 JavaPoet、KotlinPoet 帮我们生成对应的代码。 此处我们还是以 DetailActivity 为例来讲，此处需要注意的一个点是，页面的传参和方法传参都一样有必传参数和非必传参数，而且参数可能会有很多，这里我们可以考虑使用 Builder 模式来创建启动类： @Generatedpublic final class DetailActivityBuilder { // 可以生成常量，以便我们手动获取对应参数 public static final String EXTRA_ID = &quot;id&quot;; public static final String EXTRA_TITLE = &quot;title&quot;; public static final String EXTRA_USER_ID = &quot;userId&quot;; // 参数 private long id; private String title; private String userId; // 非必传参数可以通过以参数为名的方法传入 /** * @param title 详情内容 */ public DetailActivityBuilder title(String title) { this.title = title; return this; } // 必传参数需要通过 builder 方法创建出来 /** * @param id * @param userId 用户ID */ public static DetailActivityBuilder builder(long id, String userId) { DetailActivityBuilder builder = new DetailActivityBuilder(); builder.id = id; builder.userId = userId; return builder; } // 将参数存到 Intent 中，方便跳转获取 public Intent getIntent(Context context) { Intent intent = new Intent(context, DetailActivity.class); intent.putExtra(EXTRA_ID, id); intent.putExtra(EXTRA_TITLE, title); intent.putExtra(EXTRA_USER_ID, userId); return intent; } // 注入参数的逻辑 public static void inject(Activity instance, Bundle savedInstanceState) { if(instance instanceof DetailActivity) { DetailActivity typedInstance = (DetailActivity) instance; if(savedInstanceState != null) { typedInstance.id = BundleUtils.&lt;Long&gt;get(savedInstanceState, &quot;id&quot;, null); typedInstance.title = BundleUtils.&lt;String&gt;get(savedInstanceState, &quot;title&quot;, &quot;&quot;); typedInstance.userId = BundleUtils.&lt;String&gt;get(savedInstanceState, &quot;userId&quot;, &quot;&quot;); } } } // 可以将传入的参数保存到 Bundle 中，以方便屏幕旋转或其他配置发生改变时恢复 public static void saveState(Activity instance, Bundle outState) { if(instance instanceof DetailActivity) { DetailActivity typedInstance = (DetailActivity) instance; Intent intent = new Intent(); intent.putExtra(&quot;id&quot;, typedInstance.id); intent.putExtra(&quot;title&quot;, typedInstance.title); intent.putExtra(&quot;userId&quot;, typedInstance.userId); outState.putAll(intent.getExtras()); } } // NewIntent 情况 public static void processNewIntent(DetailActivity activity, Intent intent) { processNewIntent(activity, intent, true); } public static void processNewIntent(DetailActivity activity, Intent intent, Boolean updateIntent) { if(updateIntent) { activity.setIntent(intent); } if(intent != null) { inject(activity, intent.getExtras()); } } // 启动目标 Activity public void start(Context context) { Intent intent = getIntent(context); if(!(context instanceof Activity)) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); } context.startActivity(intent); } public void start(Context context, Bundle options) { Intent intent = getIntent(context); if(!(context instanceof Activity)) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); } context.startActivity(intent, options); } public void start(Activity activity, int requestCode) { Intent intent = getIntent(activity); activity.startActivityForResult(intent, requestCode); } public void start(Activity activity, int requestCode, Bundle options) { Intent intent = getIntent(activity); activity.startActivityForResult(intent, requestCode, options); } public static void finish(Activity activity) { ActivityCompat.finishAfterTransition(activity); }} 定义注解 @Builder 注解根据目标 Activity 来生成对应的 Builder 类。 @Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Builder {} @Extra 注解打在参数上的注解，用来执行解析和注入工作，类似于 ARouter 的 @Autowire 注解： @Target(ElementType.FIELD)@Retention(RetentionPolicy.CLASS)public @interface Extra { // 自定义的参数名称 String value() default &quot;&quot;; // 是否必传 boolean required() default true; // ---↓ 默认值 String stringValue() default &quot;&quot;; char charValue() default '0'; byte byteValue() default 0; short shortValue() default 0; int intValue() default 0; long longValue() default 0; float floatValue() default 0f; double doubleValue() default 0.0; boolean booleanValue() default false; // ---↑ 默认值 // 注释信息 String description() default &quot;&quot;;} 引入 APT 首先我们创建一个 compiler 的 Java Module，创建我们的注解处理器并继承于 AbstractProcessor public class ActivityBuilderProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); // 可以获取反射相关的工具，帮助我们去处理类文件 AptContext.getInstance().init(processingEnv); } @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); types.add(Builder.class.getCanonicalName()); types.add(Extra.class.getCanonicalName()); return types; } @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { // TODO 处理并生成 Builder 代码 // 收集 Activity 类信息 // 收集参数（打上 @Extra 注解的成员变量）信息 // 根据所收集的信息生成代码文件 return false; }} 注意：ActivityBuilderProcessor 需要在 META-INF 中声明： # ActivityStarter/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processorio.github.qihuan92.activitystarter.compiler.ActivityBuilderProcessor 实际上，javac 是利用 ServiceLoader加载注册文件，从而得到了 APT 实现类的类名，进而执行 Processor 中的 process() 方法。 使用 JavaPoet 生成代码 JavaPoet 是 square 推出的开源 java 代码生成框架，提供 Java Api 生成 .java 源文件。这个框架功能非常有用，我们可以很方便的使用它根据注解、数据库模式、协议格式等来对应生成代码。通过这种自动化生成代码的方式，可以让我们用更加简洁优雅的方式要替代繁琐冗杂的重复工作。 关键类说明： class 说明 JavaFile 用于构造输出包含一个顶级类的Java文件 TypeSpec 生成类，接口，或者枚举 MethodSpec 生成构造函数或方法 FieldSpec 生成成员变量或字段 ParameterSpec 用来创建参数 AnnotationSpec 用来创建注解 在 JavaPoet 中，JavaFile 是对 .java 文件的抽象，TypeSpec 是类/接口/枚举的抽象，MethodSpec 是方法/构造函数的抽象，FieldSpec 是成员变量/字段的抽象。这几个类各司其职，但都有共同的特点，提供内部 Builder 供外部更多更好地进行一些参数的设置以便有层次的扩展性的构造对应的内容。 另外，它提供 $L(for Literals)，$S(for Strings)，$T(for Types)，$N(for Names) 等标识符，用于占位替换。 有了 JavaPoet，就可以很方便的将我们上边的 Builder 代码构建出来了，包括其中的常量、构造器、传参方法、注入方法等部分。 这部分就涉及到 JavaPoet API 的调用了，在此不再赘述这部分的内容，详见 ActivityBuilderProcessor.java。 处理 startActivityForResult()上文我们处理了页面传参的情况，另外还有一种情况需要我们考虑，就是如何获取页面返回的参数，相同的，返回参数的情况也会遇到同样的问题，所以页面返回的参数也需要注解处理器帮我们处理一下。 定义 @ResultField 注解 @Retention(RetentionPolicy.CLASS)public @interface ResultField { String name(); Class&lt;?&gt; type();} 在打 @Builder 注解的时候，可以传入返回值的名称和类型： @Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Builder { ResultField[] resultFields() default {};}// 返回类型为 String 的 color 参数@Builder(resultFields = @ResultField(name = &quot;color&quot;, type = String.class))public class ColorSelectActivity extends AppCompatActivity { // ... toolbar.setNavigationOnClickListener(view -&gt; { ColorSelectActivityBuilder.finish(this, colorItem.getColor()) }); // ...} 需要注解处理器生成如下代码： // 将返回的结果封装到实体中public static class Result { public int resultCode; public String color;}public void start(Activity activity, int requestCode) { Intent intent = getIntent(activity); activity.startActivityForResult(intent, requestCode);}// 启动 Activity 解析返回参数public static Result obtainResult(int resultCode, Intent intent) { Result result = new Result(); result.resultCode = resultCode; if(intent != null) { Bundle bundle = intent.getExtras(); result.color = BundleUtils.&lt;String&gt;get(bundle, &quot;color&quot;); } return result;}// 目标 Activity 通过此方法返回结果public static void finish(Activity activity, String color) { Intent intent = new Intent(); activity.setResult(Activity.RESULT_OK, intent); intent.putExtra(&quot;color&quot;, color); ActivityCompat.finishAfterTransition(activity);} 使用： 通过定义 @ResultField 注解，来规范我们的返回结果，使用方式如下： // 返回类型为 String 的 color 参数@Builder(resultFields = @ResultField(name = &quot;color&quot;, type = String.class))public class ColorSelectActivity extends AppCompatActivity { // ... toolbar.setNavigationOnClickListener(view -&gt; { // 关闭当前页面，回传返回参数 Intent intent = new Intent(); intent.putExtra(&quot;color&quot;, colorItem.getColor()); setResult(RESULT_OK, intent); finish(); ColorSelectActivityBuilder.finish(this, colorItem.getColor()) }); // ...} 启动以及处理返回结果： // 启动页面ColorSelectActivityBuilder.builder(currentColor) .start(this, REQUEST_CODE_SELECT_COLOR);@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); // 处理返回结果 if (requestCode == REQUEST_CODE_SELECT_COLOR) { if (data != null) { String color = data.getStringExtra(&quot;color&quot;); } ColorSelectActivityBuilder.Result result = ColorSelectActivityBuilder.obtainResult(resultCode, data); String color = result.color; // TODO do something... }} 适配 Activity Result API 由于 onActivityResult() 耦合性严重的问题，谷歌官方已经不再推荐我们使用 onActivityResult() 了，推出了 Activity Result API： 虽然所有 API 级别的 Activity 类均提供底层 startActivityForResult() 和 onActivityResult() API，但我们强烈建议您使用 AndroidX Activity 和 Fragment 中引入的 Activity Result API。 Activity Result API 提供了用于注册结果、启动结果以及在系统分派结果后对其进行处理的组件。 我们从文档了解到 Activity Result API 支持我们继承 ActivityResultContract 来实现自己的 Contract，从而自定义输入和输出，所以我们可以根据对于的注解生成 ResultContract 类，来帮我们处理返回结果。 public static ActivityResultLauncher&lt;ColorSelectActivityBuilder&gt; registerForActivityResult( @NonNull ActivityResultCaller resultCaller, @NonNull ActivityResultCallback&lt;Result&gt; callback) { return resultCaller.registerForActivityResult(new ResultContract(), callback);}public static class Result { public int resultCode; public String color;}// 我们定义输入为目标Builder，输出为返回结果public static class ResultContract extends ActivityResultContract&lt;ColorSelectActivityBuilder, Result&gt; { @NonNull @Override public Intent createIntent(@NonNull Context context, ColorSelectActivityBuilder input) { return input.getIntent(context); } @Override public Result parseResult(int resultCode, @Nullable Intent intent) { return obtainResult(resultCode, intent); }} 调用方式如下： // 注册启动器private final ActivityResultLauncher&lt;ColorSelectActivityBuilder&gt; launcher = ColorSelectActivityBuilder.registerForActivityResult(this, result -&gt; { if (result.resultCode == RESULT_OK) { String color = result.color; btnSelectColor.setBackgroundColor(Color.parseColor(color)); Toast.makeText(this, &quot;选中颜色: &quot; + color, Toast.LENGTH_SHORT).show(); currentColor = color; } }); // 启动页面launcher.launch(ColorSelectActivityBuilder.builder(currentColor)); 这样我们就可以更方便的借助 Activity Result API 来帮助我们处理页面返回值了。 还有哪些可以优化的？使用切面编程简化 inject()我们每一个打上 @Builder 的目标 Activity 都需要在 onCreate() 函数来进行参数的注入，这部分我们可以使用切面编程的方式，在 Application 中注册一个 Activity 生命周期的监听器来反射调用目标 ActivityBuilder 的 inject() 方法，以此来进一步简化代码。 // 在应用的 Application 中注册 Activity 生命周期的回调application.registerActivityLifecycleCallbacks(new StarterActivityLifecycleCallbacks());class StarterActivityLifecycleCallbacks implements Application.ActivityLifecycleCallbacks { @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle bundle) { // 反射处理参数注入逻辑 performInject(activity, bundle); } // .... @Override public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle bundle) { // 处理参数保存逻辑 performSaveState(activity, bundle); } private void performInject(Activity activity, Bundle savedInstanceState) { try { if (savedInstanceState == null) { Intent intent = activity.getIntent(); if (intent == null) { return; } savedInstanceState = intent.getExtras(); } BuilderClassFinder.findBuilderClass(activity).getDeclaredMethod(&quot;inject&quot;, Activity.class, Bundle.class).invoke(null, activity, savedInstanceState); } catch (Exception e) { Log.w(&quot;ActivityStarter&quot;, e); } } private void performSaveState(Activity activity, Bundle outState) { try { BuilderClassFinder.findBuilderClass(activity).getDeclaredMethod(&quot;saveState&quot;, Activity.class, Bundle.class).invoke(null, activity, outState); } catch (Exception e) { Log.w(&quot;ActivityStarter&quot;, e); } }} Kotlin 扩展函数由于我们项目中越来越多的业务使用 Kotlin，我们都知道 Kotlin 的扩展函数可以简化我们的代码，可以提升一定的开发效率。 可以使用 KotlinPoet 来生成一些扩展函数，例如： 启动页面方法的扩展函数 // DetailActivityBuilder.kt// 通过可控参数的方式来处理非必传参数fun Context.startDetailActivity(id: Long, userId: String, title: String? = null) { val builder = DetailActivityBuilder.builder(id, userId) .title(title) builder.start(this)} 在 Activity 中调用方式如下： startDetailActivity(123456L, &quot;999999&quot;, &quot;测试标题&quot;) Activity Result API 扩展函数 // ColorSelectActivityBuilder.ktfun AppCompatActivity.registerForColorSelectActivityResult( callback: (ColorSelectActivityBuilder.Result) -&gt; Unit): ActivityResultLauncher&lt;ColorSelectActivityBuilder&gt; { return ColorSelectActivityBuilder.registerForActivityResult(this) { callback(it) }}fun ActivityResultLauncher&lt;ColorSelectActivityBuilder&gt;.launch(color: String) { val builder = ColorSelectActivityBuilder.builder(currentColor) launch(builder)} 调用方式如下： private val launcher = registerForColorSelectActivityResult { if (it.resultCode == RESULT_OK) { currentColor = it.color }}binding.btnSelectColor.setOnClickListener { launcher.launch(currentColor)} finish 扩展函数 public fun KotlinActivity.finish(testResult: String): Unit { KotlinActivityBuilder.finish(this, testResult)} 调用方式如下： finish(&quot;success&quot;) 开发 IDEA 插件支持快速跳转到目标 Activity当我们使用原来的方法进行开发时，在 Android Studio 里边很方便的就可以跳转到目标 Activity： DetailActivity.start( this, 123456L, &quot;100008&quot;, &quot;测试标题&quot;); 但是我们使用注解处理器生成的 Builder 类时，则无法很方便的直接跳转到目标 Activity，所以需要开发插件来支持。 在 IDEA 插件开发中支持添加 LineMarker，可以通过此标记来进行一些操作。 插件的关键代码如下： class NavigationLineMarker : LineMarkerProviderDescriptor(), GutterIconNavigationHandler&lt;PsiElement&gt; { companion object { const val GENERATED_ANNOTATION_NAME = &quot;io.github.qihuan92.activitystarter.annotation.Generated&quot; const val NOTIFY_SERVICE_NAME = &quot;ActivityStarter Plugin Tips&quot; const val NOTIFY_TITLE = &quot;Road Sign&quot; const val NOTIFY_NO_TARGET_TIPS = &quot;No destination found or unsupported type.&quot; val logger = Logger.getInstance(NavigationLineMarker::class.java) } private val navigationOnIcon = IconLoader.getIcon(&quot;/icon/ic_jump.png&quot;) override fun getName() = &quot;ActivityStarter Location&quot; override fun getLineMarkerInfo(element: PsiElement): LineMarkerInfo&lt;*&gt;? { // 找到 builder 方法，添加标记 if (isNavigationCall(element)) { return LineMarkerInfo( element, element.textRange, navigationOnIcon, Pass.UPDATE_ALL, null, this, GutterIconRenderer.Alignment.LEFT ) } return null } override fun navigate(e: MouseEvent?, element: PsiElement?) { if (element == null) { return } if (element is PsiCallExpression) { val method = element.resolveMethod() ?: return val parent = method.parent // 获取目标 Activity 全类名 val activityName = (parent as PsiClass).qualifiedName?.dropLast(&quot;Builder&quot;.length) ?: return logger.info(&quot;activityName: $activityName&quot;) // 在项目中查找类并进行跳转 val fullScope = GlobalSearchScope.allScope(element.project) val findClass = JavaPsiFacade.getInstance(element.project).findClass(activityName, fullScope) NavigationItem::class.java.cast(findClass).navigate(true) return } Notifications.Bus.notify( Notification( NOTIFY_SERVICE_NAME, NOTIFY_TITLE, NOTIFY_NO_TARGET_TIPS, NotificationType.WARNING ) ) } private fun isNavigationCall(psiElement: PsiElement): Boolean { if (psiElement is PsiCallExpression) { val method = psiElement.resolveMethod() ?: return false val parent = method.parent if (method.name == &quot;builder&quot; &amp;&amp; parent is PsiClass) { logger.info(&quot;builder caller: ${parent.name}&quot;) if (parent.hasAnnotation(GENERATED_ANNOTATION_NAME)) { return true } } } return false }} 在 Android Studio 中可以本地安装打包好的插件： 效果如下： TODO 支持通过路由来处理无依赖关系的组件间的页面跳转 支持 KSP 结语通过启动页面传参和处理返回值的这个点，我们大概了解了注解处理器的使用，以及可以解决开发中的哪些问题，可以解放我们的双手，从而提高我们的开发效率。 我们也可以从 ButterKnife、ARouter 和 Dagger 等优秀的框架学习注解处理器的更为进阶的使用，以及他们是如何通过这个工具来解决我们开发过程中的一些问题的。重要的是思路，以及我们可以在开发过程中发现怎样的问题，并善用工具去解决这些问题。 附上源码地址：https://github.com/qihuan92/ActivityStarter","link":"/2022/11/07/android-apt-activity-starter/"},{"title":"Android AMS 原理解读","text":"AMS（ActivityManagerService） 在 Android 中占据着非常重要的地位，它是 Framework 核心服务之一，负责四大组件的统一调度。同时，AMS 也管理着进程、电池、内存及权限。注：文中源码来源于 Android API 30 Zygote 进程Zygote 为受精卵的意思，由名称可以看得出来，Zegote 进程的主要作用就是分裂（fork）进程。 Zygote 的启动流程app_main.cpp -&gt; main() -&gt; 初始化 AndroidRuntime -&gt; runtime.start() -&gt; AndroidRuntime.start() startVM() 启动虚拟机从上述流程可以看出，一个进程包裹了一个虚拟机。 startReg() 注册 JNI env -&gt; CallStaticVoidMethod() -&gt; ZygoteInit.main()通过 JNI 调用 ZygoteInit.main() 进入到 Java 层。 ZygoteInit.main()public class ZygoteInit { // ... public static void main(String argv[]) { // ... if (!enableLazyPreload) { // ... // 1. 预加载信息，加载了一部分 Framework 的资源，以及常用的 Java 类，加快了应用进程的启动 preload(bootTimingsTraceLog); // ... } // ... // 2. 创建 Socket zygoteServer = new ZygoteServer(isPrimaryZygote); // ... if (startSystemServer) { // 3. 通过 fork，创建 SystemServer 进程 Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); if (r != null) { r.run(); return; } } // 4. 进入循环，等待 AMS 消息，创建线程 caller = zygoteServer.runSelectLoop(abiList); // ... } // ...} ZygoteInit.main() 主要做了以下几个事情： 预加载 创建 Socket为什么不用 Binder？ Binder 还没有初始化完成。 Binder 是多线程机制，fork 时容易死锁。 fork SystemServer 进程 如果返回的 Runnable 不为空则通过反射执行 SystemServer.main() 方法。 如果返回的 Runnable 为空则标识当前进程为父进程，也就是 Zygote 进程，接着就会执行第四步进行循环等待。 等待 AMS 消息，创建线程 SystemServer 进程SystemServer 进程是 zygote 进程第一个 fork 出来的进程，AMS、WMS 以及 PMS 等都是由 SystemServer 进程启动的。我们进入 ZygoteInit.forkSystemServer() 看一下 SystemServer 进程的创建过程： private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { // ... try { // ... // fork SystemServer 进程，并返回子进程的 pid pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } // pid 为 0 表示当前进程为 fork 出来的进程，也就是 SystemServer 进程 if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } zygoteServer.closeServerSocket(); // 处理 SystemServer 进程 return handleSystemServerProcess(parsedArgs); } return null;} 下边我们经过 ZygoteInit.handleSystemServerProcess() -&gt; ZygoteInit.zygoteInit() -&gt; RuntimeInit.applicationInit() -&gt; RuntimeInit.findStaticMain() 这几个方法的调度，进入了 RuntimeInit.findStaticMain() 方法： public class RuntimeInit { // ... protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; // 通过反射执行 SystemServer.main() 方法 try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( &quot;Missing class when invoking static main &quot; + className, ex); } Method m; try { m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); } catch (SecurityException ex) { throw new RuntimeException( &quot;Problem getting static main on &quot; + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( &quot;Main method is not public and static on &quot; + className); } return new MethodAndArgsCaller(m, argv); } // ... static class MethodAndArgsCaller implements Runnable { /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) { mMethod = method; mArgs = args; } // 在 ZygoteInit.main() 方法中执行 public void run() { try { mMethod.invoke(null, new Object[] { mArgs }); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } throw new RuntimeException(ex); } } }} findStaticMain() 返回一个 MethodAndArgsCaller 对象，而 MethodAndArgsCaller 是一个 Runnable 最终在 ZygoteInit.main() 中执行。下面我们进入到 SystemServer.main() -&gt; run() 方法看一下： private void run() { // ... // 创建系统 Context createSystemContext(); // 初始化主线模块 ActivityThread.initializeMainlineModules(); // 创建 SystemServiceManager mSystemServiceManager = new SystemServiceManager(mSystemContext); // ... // 启动系统引导服务，如 AMS、PMS startBootstrapServices(t); // 启动核心服务，如电池服务 startCoreServices(t); // 启动其他服务，如 WMS startOtherServices(t); // ... // 开启循环 Looper.loop();} startBootstrapServices()接着进入到 startBootstrapServices() 方法，看下 AMS 的启动： private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) { // ... // 启动 ATMS（Android 10 之后） ActivityTaskManagerService atm = mSystemServiceManager.startService(ActivityTaskManagerService.Lifecycle.class).getService(); // 启动 AMS mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // ... // 将 AMS 保存到 ServiceManager mActivityManagerService.setSystemProcess(); // ...} ActivityTaskManagerService 创建 Activity 生命周期管理类 ClientLifecycleManager publishBinderService() -&gt; ServiceManager.addServer()将 ATM 服务保存到 ServiceManager 中 ActivityManagerService 的创建 ActivityManagerService.setSystemProcess() 将 AMS 保存到 ServiceManager startOtherServices()private void startOtherServices(@NonNull TimingsTraceAndSlog t) { // ... // 创建 WMS wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); // ... // 将 WMS 绑定到 AMS mActivityManagerService.setWindowManager(wm); // ... // 应用的启动 mActivityManagerService.systemReady(() -&gt; { // ... }, t);} 在 startOtherServices() 函数中可以看到启动了很多服务，其中就有 WMS，最后调用应用的启动 systemReady() 方法。 ActivityManagerServiceActivityManagerService 的创建在 ActivityManagerService.Lifecycle 类的构造方法中创建了 ActivityManagerService 对象 public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; private static ActivityTaskManagerService sAtm; public Lifecycle(Context context) { super(context); // 创建 ActivityManagerService 对象 mService = new ActivityManagerService(context, sAtm); } public static ActivityManagerService startService(SystemServiceManager ssm, ActivityTaskManagerService atm) { sAtm = atm; return ssm.startService(ActivityManagerService.Lifecycle.class).getService(); } // ...} 进入 ActivityManagerService 的构造方法看下： public ActivityManagerService(Context systemContext, ActivityTaskManagerService atm) { // ... // 调用 ATM 初始化 mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController, DisplayThread.get().getLooper()); // ...} 其中关键的部分是调用 ATM 的初始化 public class ActivityTaskManagerService extends IActivityTaskManager.Stub { // ... public void initialize(IntentFirewall intentFirewall, PendingIntentController intentController, Looper looper) { // ... // 创建栈管理对象 ActivityStackSupervisor mStackSupervisor = createStackSupervisor(); // ... // 设置当前任务栈 setRecentTasks(new RecentTasks(this, mStackSupervisor)); // ... } // ...} 启动页面ActivityManagerService.systemReady() 对 Activity 启动的管理 Activity.startActivity() -&gt; Instrumentation.execStartActivity() public class Instrumentation { // ... public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { // ... try { intent.migrateExtraStreamToClipData(who); intent.prepareToLeaveProcess(who); // 通过 Binder 跨进程调用 ActivityTaskManager 启动 Activity // 在 Android 9 之前是通过 AMS 启动的 int result = ActivityTaskManager.getService().startActivity(whoThread, who.getBasePackageName(), who.getAttributionTag(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } // ...} 通过 ServiceManager 获取 ATM 服务，并调用 ATM 服务的 startActivity() 方法启动 Activity。扩展：ActivityTaskManager.getService() 用到了代理模式。 下面我们看一下 startActivity() 的调用链： -&gt; ActivityTaskManagerService.startActivity()-&gt; ActivityTaskManagerService.startActivityAsUser()-&gt; ActivityStarter.startActivityUnchecked()-&gt; ActivityStarter.startActivityInner()-&gt; RootWindowContainer.resumeFocusedStacksTopActivities()-&gt; ActivityStack.resumeFocusedStacksTopActivities()-&gt; ActivityStack.resumeTopActivityInnerLocked()-&gt; ActivityStackSupervisor.startSpecificActivity() 后边比较关键的是 ActivityStackSupervisor.startSpecificActivity() 方法： // ActivityStackSupervisor.classvoid startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; // 判断进程是否启动 if (wpc != null &amp;&amp; wpc.hasThread()) { try { realStartActivityLocked(r, wpc, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. knownToBeDead = true; } // 进程不存在的情况，用 Socket 通知 Zygote fork 应用的进程 r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity(); mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? &quot;top-activity&quot; : &quot;activity&quot;);} 进入到 startSpecificActivity() 方法， 如果进程未启动，则用 Socket 通知 Zygote fork 应用的进程，然后用反射的方式调用 ActivityThread.main() 方法。进入 main() 方法后会执行 attach() 方法，此时传入的 system 参数为 false，可以看出 ActivityThread 通过快进程（Binder）的方式将 ActivityThread 传给 AMS。public final class ActivityThread extends ClientTransactionHandler { // ... public static void main(String[] args) { // ... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); // ... } // ... private void attach(boolean system, long startSeq) { // ... if (!system) { // ... // 通过跨进程(Binder)的方式将 ActivityThread 传给 AMS RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); mgr.attachApplication(mAppThread, startSeq); } else { // ... } }} 如果应用程序已启动，则调用 realStartActivityLocked() 方法，执行 Activity 的生命周期。 AMS 如何管理新的进程的 Activity 的生命周期 // ActivityStackSupervisor.classboolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException { // ... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; // create start clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(), results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken, r.createFixedRotationAdjustmentsIfNeeded())); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) { // resume lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); } else { lifecycleItem = PauseActivityItem.obtain(); } // Schedule transaction. mService.getLifecycleManager().scheduleTransaction(clientTransaction); // ...} 接着就会调用 ClientLifecycleManager.scheduleTransaction() 方法： -&gt; ClientLifecycleManager.scheduleTransaction()-&gt; ClientTransaction.schedule()-&gt; IApplicationThread.scheduleTransaction() -&gt; ActivityThread.ApplicationThread.scheduleTransaction() -&gt; ActivityThread.scheduleTransaction() -&gt; ActivityThread.H.handleMessage() -&gt; msg=EXECUTE_TRANSACTION =&gt; TransactionExecutor.excute() -&gt; executeCallbacks() =&gt; LaunchActivityItem -&gt; executeLifecycleState() =&gt; state=ON_START &amp; state=ON_RESUME 面试题为什么使用 Zygote fork 应用进程，而不是用 Init 或者 SystemServer？ 虚拟机的启动是在 Zygote 进程的，在 Init 进程虚拟机还没有启动；Init 进程除了启动 Zygote 进程，还会启动的一些其他进程，而这些进程与应用进程不相关。 SystemServer 会启动 AMS、WMS、PMS 等很多系统服务，这些服务是所有的应用进程公用的。 SystemServiceManager 和 ServiceManager 的区别 SystemServiceManager 是专门用来管理 SystemService 的生命周期的，例如 ActivityManagerService.Lifecycle 和 ActivityTaskManagerService.Lifecycle 等。 ServiceManager 是用来管理系统服务的，ServiceManager 通过 addService() 方法添加服务，通过 getService() 获取服务。 如何启动一个未注册的 Activity（插件化原理） https://www.jianshu.com/p/4fc77fbac938https://woaitqs.cc/2016/08/17/2016-08-17-launch-activity-without-registering-in-manifest/ 首先在 AndroidManifest 中注册一个占位的 Activity 在启动 Activity 的地方中的 Intent 里边的目标 Activity 替换为占位 Activity 寻找合适的 hook 点，在 ActivityThread 启动 Activity 的时候，再将占位的 Activity 替换为目标 Activity。","link":"/2021/12/22/android-ams/"},{"title":"Android Handler 原理分析","text":"Handler 是 Android 应用非常重要的组成部分，它的身影可谓是无处不在了，从系统源码到第三方库，再到我们开发的过程中都离不开 Handler。许多开发中的问题也涉及到 Handler 相关的知识，例如 ANR 问题、UI 的绘制以及线程的调度等，本文将从源码分析、常见问题以及 Handler 的一些应用等方面进行分析。 Handler 原理分析什么是 Handler下边是官网对于 Handler 的定义 A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper. It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread. 其大概意思就是说，Handler 可以发送 Message 或 Runnable 到消息队列（MessageQueue）中，每一个 Handler 实例和一个线程及这个线程的消息队列相关联。创建一个 Handler 实例时需要和一个 Looper 进行绑定，它向这个 Looper 所在的线程的消息队列发送消息，并在当前的线程处理这些消息。 Handler 工作流程Handler 的工作流程如下图所示：我们可以看出，Looper 为消息队列提供动力，不断地循环消息队列中的消息，Handler 向消息队列发送消息并处理消息。Handler 关键方法调用如下所示： Android 主线程中的 Handler从官网定义中，我们得知创建一个 Handler 实例时需要和一个 Looper 进行绑定，那么我们在平常使用 Handler 时并没有接触过 Looper 这个东西，这是因为在主线程创建 Handler 之前，Android 已经创建了一个 Looper 并开启了循环。我们可以看下应用的入口 ActivityThread.main() 方法： // ActivityThread.javapublic static void main(String[] args) { // ... // 创建 Looper Looper.prepareMainLooper(); // ... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); // 获取当前线程 Handler if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } // ... // Looper 开启循环 Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);} Looper.prepare()首先调用了 Looper.prepareMainLooper() 方法： public final class Looper { // 这里创建一个 ThreadLocal 用来存放 Looper，保证一个线程都有一个自己的 Looper static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); // ... public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); } } private static void prepare(boolean quitAllowed) { // 当 Looper 已经初始化，则不可以再次创建 if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } // 创建一个 Looper，并放到 ThreadLocal 中 sThreadLocal.set(new Looper(quitAllowed)); }} 在 Looper.prepareMainLooper() 方法中又调用了 prepare() 方法，这个方法会创建一个 Looper，然后将这个 Looper 放到一个 ThreadLocal 中，并且在之前还进行了防止重复的校验。也就是说一个线程都有自己单独的 Looper，且只能创建一次。 然后再跟进到 Looper 的构造方法看一下： // Looper.javaprivate Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} Looper 在创建的时候也创建了消息队列，也就是说每一个线程中只能有一个 Looper 和 MessageQueue。 ActivityThread.H我们再来看一下 ActivityThread 中的 sMainThreadHandler = thread.getHandler(); 这行代码，thread.getHandler() 实际上是获取的 ActivityThread 中的内部类 mH，这个 Handler 负责处理四大组件以及 Application 的一些消息。 //ActivityThread.javaclass H extends Handler { // ... public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case EXIT_APPLICATION: if (mInitialApplication != null) { mInitialApplication.onTerminate(); } Looper.myLooper().quit(); break; case RECEIVER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveComp&quot;); handleReceiver((ReceiverData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceUnbind&quot;); handleUnbindService((BindServiceData)msg.obj); schedulePurgeIdler(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceStop&quot;); handleStopService((IBinder)msg.obj); schedulePurgeIdler(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ··· case APPLICATION_INFO_CHANGED: mUpdatingSystemConfig = true; try { handleApplicationInfoChanged((ApplicationInfo) msg.obj); } finally { mUpdatingSystemConfig = false; } break; case RUN_ISOLATED_ENTRY_POINT: handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2); break; case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); if (isSystem()) { // Client transactions inside system process are recycled on the client side // instead of ClientLifecycleManager to avoid being cleared before this // message is handled. transaction.recycle(); } // TODO(lifecycler): Recycle locally scheduled transactions. break; case RELAUNCH_ACTIVITY: handleRelaunchActivityLocally((IBinder) msg.obj); break; case PURGE_RESOURCES: schedulePurgeIdler(); break; } Object obj = msg.obj; if (obj instanceof SomeArgs) { ((SomeArgs) obj).recycle(); } if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what)); }} Looper.loop()最后我们再看一下 Looper.loop() 方法： // Looper.javapublic static void loop() { // 获取ThreadLocal中的Looper final Looper me = myLooper(); // ... final MessageQueue queue = me.mQueue; // ... // 死循环 for (;;) { // 获取消息 Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // ... // 处理消息 msg.target.dispatchMessage(msg); //... // 回收复用 msg.recycleUnchecked(); }} 在 loop 方法中是一个死循环，在这里从消息队列中不断的获取消息 queue.next()，然后通过 Handler.dispatchMessage() 进行消息的分发，其实并没有什么具体的绑定，因为 Handler 在每个线程中对应只有一个 Looper 和消息队列 MessageQueue，自然要靠它来处理，也就是是调用 Looper.loop() 方法。在 Looper.loop() 的死循环中不断的取消息，最后回收复用。 这里注意 Message 中的 target（Handler） 这个成员变量，正是有了这个变量，每个 Message 才能找到它所对应的 Handler，让多个 Handler 同时工作处理各自的消息 注意：在创建 Message 时，应该使用 Message.obtain() 方法创建，这样所有的消息会被回收，放入 sPool 中，使用享元设计模式。 Looper 死循环会消耗大量的资源吗？关键就在 queue.next() 消息队列取消息的地方 // MessageQueue.javaMessage next() { final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { // Linux pipe/epoll 机制，在没有消息的时候阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // 获取开机到现在的时间 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. // 没到执行时间，计算等待时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE; } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // ... } }} 在 MessageQueue.next() 方法中，会调用 nativePollOnce() 本地方法，这里会利用 Linux 的 pipe/epoll 机制，在没有消息的时候阻塞在这里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪（读或写就绪），则立刻通知相应程序进行读或写操作，本质同步 I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。关于 Linux 的 pipe/epoll 机制，可移步此文。 nativePollOnce()// android_os_MessageQueue.cpp// ...static jboolean android_os_MessageQueue_nativeIsPolling(JNIEnv* env, jclass clazz, jlong ptr) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;getLooper()-&gt;isPolling();}// ...void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) { mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) { env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; }}// ... // Looper.cpp// ...int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) { // ... result = pollInner(timeoutMillis);}// ...int Looper::pollInner(int timeoutMillis) { // ... // 利用 epoll_wait() 进行阻塞等待 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // ...} 主线程的 Handler 的退出在 App 退出时，ActivityThread 中的 mH（Handler）收到消息后，执行退出。 // ActivityThread.H.handleMessage()case EXIT_APPLICATION: if (mInitialApplication != null) { mInitialApplication.onTerminate(); } Looper.myLooper().quit(); break; 注意：当我们尝试手动退出时会抛出如下异常，这是因为主线程不允许退出，一旦退出就意味着程序挂了，退出也不应该用这种方式退出。 Caused by: java.lang.IllegalStateException: Main thread not allowed to quit. 关于 ThreadLocal从 Looper 的源码中，我们可以看到创建 Looper 实例后，将它放到了 ThreadLocal 中，以保证线程中各自都有一个 Looper 实例。ThreadLocal 为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。 ThreadLocal 原理Java 的实现里面有一个 Map，叫做 ThreadLocalMap，持有 ThreadLocalMap 的是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。 public class Thread implements Runnable { // 内部持有 ThreadLocalMap ThreadLocal.ThreadLocalMap threadLocals = null;}class ThreadLocal&lt;T&gt; { public T get() { // 首先获取线程持有的 ThreadLocalMap ThreadLocalMap map = Thread.currentThread().threadLocals; // 在 ThreadLocalMap 中查找变量 Entry e = map.getEntry(this); return e.value; }}static class ThreadLocalMap { // 内部是数组而不是 Map Entry[] table; // 根据 ThreadLocal 查找 Entry Entry getEntry(ThreadLocal key){ //...查找 } // Entry static class Entry extends WeakReference&lt;ThreadLocal&gt;{ Object value; } } 在 Java 的实现方案中，ThreadLocal 仅仅只是一个代理工具类，内部并不持有任何线程相关的数据，所有和线程相关的数据都存储在 Thread 里面，这样的设计从数据的亲缘性上来讲，ThreadLocalMap 属于 Thread 也更加合理。所以 ThreadLocal 的 get() 方法，其实就是拿到每个线程独有的 ThreadLocalMap。这种设计方案的好处就是不容易产生内存泄漏，如果在 ThreadLocal 用一个键为 Thread 值为存储的内容的 Map 这种设计方案，ThreadLocal 持有的 Map 会持有 Thread 对象的引用，这就意味着只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往都比线程要长，所以这种设计方案很容易导致内存泄漏。而 Java 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用，所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。Java 的实现方案虽然看上去复杂一些，但是更安全。 ThreadLocal 与内存泄漏但是如果在线程池中使用 ThreadLocal 可能会导致内存泄漏，原因是线程池中线程的存活时间太长，往往和程序都是同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用，所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄漏。我们可以通过 try{} finally{} 方案来手动释放资源。 ExecutorService es;ThreadLocal tl;es.execute(()-&gt;{ //ThreadLocal增加变量 tl.set(obj); try { // 省略业务逻辑代码 }finally { // 手动清理ThreadLocal tl.remove(); }}); Handler 的同步屏障机制简介Handler 加入了同步屏障机制，来实现异步消息优先执行的功能。Handler 通过 MessageQueue.postSyncBarrier() 发送同步屏障，MessageQueue.removeSyncBarrier() 移除同步屏障。 同步屏障的作用可以理解成拦截同步消息的执行，主线程的 Looper 会一直循环调用 MessageQueue.next() 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。当 next() 方法在取 Message 时发现队头是一个同步屏障的消息时，就会去遍历整个队列，只寻找设置了异步标志的消息，如果有找到异步消息，那么就取出这个异步消息来执行，否则就让 next() 方法陷入阻塞状态。如果 next() 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，不处理消息。总的来说就是队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除出队列，否则主线程就一直不会去处理同步屏幕后面的同步消息。而所有消息默认都是同步消息，只有手动设置了异步标志，这个消息才会是异步消息。但是同步屏障消息只能由 Android 内部来发送，这个接口不提供给应用开发者使用。 Choreographer 与同步屏障机制Choreographer 里所有跟 message 有关的代码，都设置了异步消息的标志，所以这些操作是不受到同步屏障影响的。这样做的原因可能就是为了尽可能保证在接收到屏幕刷新信号时，可以在第一时间执行遍历绘制 View 树的工作（doTraversal()），在绘制工作的时候，如果有其他同步消息都要等到 doTraversal() 之后来避免掉帧现象。那么，有了同步屏障消息的控制就能保证每次一接收到屏幕刷新信号就第一时间处理遍历绘制 View 树的工作么？答案是不一定的，因为同步屏障是在 scheduleTraversals() 方法被调用时才发送到消息队列里的，也就是说，只有当某个 View 发起了刷新请求时，在这个时刻后面的同步消息才会被拦截掉，而在 scheduleTraversals() 之前就发送到消息队列里的工作仍然会按顺序依次被取出来执行。关于屏幕刷新机制可参考这篇文章。 如何监听应用的帧率？可通过 Choreographer.getInstance().postFrameCallback() 来监听帧率情况： public class FPSFrameCallback implements Choreographer.FrameCallback { private static final String TAG = &quot;FPS_TEST&quot;; private long mLastFrameTimeNanos; private long mFrameIntervalNanos; public FPSFrameCallback(long lastFrameTimeNanos) { mLastFrameTimeNanos = lastFrameTimeNanos; // 每一帧渲染时间（纳秒） mFrameIntervalNanos = (long) (1000000000 / 60.0); } @Override public void doFrame(long frameTimeNanos) { // frameTimeNanos 为 Vsync 信号到来的时间 // 初始化时间 if (mLastFrameTimeNanos == 0) { // 上一帧的渲染时间 mLastFrameTimeNanos = frameTimeNanos; } final long jitterNanos = frameTimeNanos - mLastFrameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt; 5) { Log.d(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames! &quot; + &quot;The application may be doing too much work on its main thread.&quot;); } } mLastFrameTimeNanos = frameTimeNanos; // 注册下一帧回调 Choreographer.getInstance().postFrameCallback(this); }} 在 Application 中注册 FPSFrameCallback： Choreographer.getInstance().postFrameCallback(FPSFrameCallback(System.nanoTime())) Handler 中的锁在不同的线程都可以使用 Handler 来发送消息，那么它是怎么保证线程安全的呢？Handler 通过 Handler.sendMessage()、Handler.post() 等方法发送消息，会调到 MessageQueue.enqueueMessage() 方法： // MessageQueue.javaboolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } // 使用 synchronized 关键字保证线程安全 synchronized (this) { // ... } // ...} 其内部通过 synchronized 关键字保证线程安全，同时 MessageQueue.next() 内部也会通过 synchronized 加锁，确保取的时候线程安全，同时插入也会加锁。 MessageQueue.next() 方法中的 synchronized 为 this 加锁，意思是为 MessageQueue 对象加锁。关于锁的机制会在其他文章展开。(TODO) 面试题Handler 是如何进行线程切换的？原理很简单，线程间是共享资源的，子线程通过 Handler.sendMessage()、Handler.post() 等方法发送消息，然后通过 Looper.loop() 在消息队列中不断的循环检索消息，最后交给 Handler.dispatchMessage() 方法进行消息的分发处理。 Handler 为什么会导致内存泄漏？为什么其他的类没有出现内存泄漏的问题，比如 Adapter 中的 ViewHolder。当在 Activity 中创建非静态的 Handler 类时，这个 Handler 为 Activity 的匿名内部类，当它调用 Activity 的方法时，Handler 是持有 Activity 的，导致 Activity 无法回收。Adapter 中的 ViewHolder 没有内存泄漏的原因是因为 ViewHolder 的生命周期比 Adapter 短。但是 Handler 的生命周期可能比 Activity 的生命周期长，比如延时发送消息的情况。 如何在子线程中创建 Handler？因为在子线程中是不存在 Looper 的，所以先要创建一个 Looper，也就是调用 Looper.prepare() 方法，并调用 Looper.loop() 方法，使 Looper 运转起来，这样子线程的 Handler 才能正常使用。 new Thread(new Runnable() { @Override public void run() { // 创建Looper，MessageQueue Looper.prepare(); new Handler().post(new Runnable() { @Override public void run() { // 处理一些逻辑... } }); // 开始处理消息 Looper.loop(); }}).start(); 这里需要注意在所有事情处理完成后应该调用 quit() 方法来终止消息循环，否则这个子线程就会一直处于循环等待的状态，因此不需要的时候终止 Looper，调用 Looper.myLooper().quit()。 如何在主线程中访问网络？在网络请求之前添加如下代码： StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitNetwork().build();StrictMode.setThreadPolicy(policy); StrictMode（严苛模式）Android2.3 引入，用于检测两大问题：ThreadPolicy（线程策略）和VmPolicy(VM策略)，这里把严苛模式的网络检测关了，就可以在主线程中执行网络操作了，一般是不建议这么做的。关于严苛模式可以查看这里。 系统为什么不建议在子线程中访问 UI？这是因为 Android 的 UI 控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，那么为什么系统不对 UI 控件的访问加上锁机制呢？缺点有两个： 首先加上锁机制会让 UI 访问的逻辑变得复杂。 锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。 子线程如何通知主线程更新 UI? 主线程中定义 Handler，子线程通过 mHandler 发送消息，主线程 Handler 的 handleMessage 更新 UI。 用 Activity 对象的 runOnUiThread 方法。 创建 Handler，传入 getMainLooper()。 View.post(Runnable r) 。 Looper 死循环为什么不会导致应用卡死，会耗费大量资源吗？Looper 并非简单地死循环，无消息时会休眠。Android 是基于消息处理机制的，用户的行为都在这个 Looper 循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作。-&gt; 如何处理 Handler 使用不当造成的内存泄漏？ 有延时消息，在界面关闭后及时移除 Message/Runnable，调用 handler.removeCallbacksAndMessages(null) 内部类导致的内存泄漏改为静态内部类，并对上下文或者 Activity/Fragment 使用弱引用。 如果有个延时消息，当界面关闭时，该 Handler 中的消息还没有处理完毕，那么最终这个消息是怎么处理的？比如打开界面后延迟 10s 发送消息，关闭界面，最终在 Handler（匿名内部类创建的）的 handleMessage() 方法中还是会收到消息。因为会有一条 MessageQueue -&gt; Message -&gt; Handler -&gt; Activity 的引用链，所以 Handler 不会被销毁，Activity 也不会被销毁。 丢帧的原因有哪些？ 遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms。 主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。 手写一个简版的 Handlerhttps://github.com/qihuan92/Playground/tree/master/handler","link":"/2021/12/27/android-handler/"},{"title":"Android 触摸事件分发机制","text":"Android 中的触摸事件是一个老生常谈的话题了，在 Android 面试中也经常问到，比较考察基础以及解决问题的能力，最近在巩固基础知识，希望通过本文对这个问题有更加深入的理解。 事件类型在事件分发的过程中，MotionEvent 对象记录时间的触摸事件，例如点击、移动。 一次完整的 MotionEvent，包含用户触摸屏幕到离开屏幕。 事件 发生次数 描述 ACTION_DOWN 1 手指触摸时触发 ACTION_MOVE 1 ~ N 手指在屏幕上滑动时触发 ACTION_UP 1 手指离开屏幕时触发 ACTION_CANCEL 0 ~ 1 事件被上层拦截时触发 核心方法时间的分发流程涉及到三个核心方法 ： dispatchTouchEvent(MotionEvent event) 事件分发 onInterceptTouchEvent(MotionEvent ev) 事件拦截，只有 ViewGroup 有 onTouchEvent(MotionEvent event) 事件响应 事件分发涉及到的类包含 View、ViewGroup 和 Activity 等，他们都能处理触摸事件的分发，但是其方法有些区别。 方法 View ViewGroup Activity dispatchTouchEvent() √ √ √ onInterceptTouchEvent() × √ × onTouchEvent() √ √ √ 分发流程当 UI 主线程收到底层上报的 input 事件，会调用 InputEventReceiver.dispachInputEvent() 方法。 整个事件分发流程如下图： DecorView.dispatchTouchEvent()// DecorView.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { final Window.Callback cb = mWindow.getCallback(); return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);} Activity 实现了 Window.Callback 接口，所以事件会分发到 Activity.dispatchTouchEvent。 Activity.dispatchTouchEvent()// Activity.javapublic boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { // 第一次按下屏幕的方法 onUserInteraction(); } // PhoneWindow.superDispatchTouchEvent(ev) if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 没有 View 处理事件时，调用 Activity.onTouchEvent(ev) return onTouchEvent(ev);} PhoneWindow.superDispatchTouchEvent()// PhoneWindow.javapublic boolean superDispatchTouchEvent(KeyEvent event) { return mDecor.superDispatcTouchEvent(event);} PhoneWindow 的顶层 View 是 DecorView，接着又会调用 DecorView 的 superDispatcTouchEvent() 方法，在 DecorView 中又调用了父类的 dispatchTouchEvent() 方法。 // DecorView.javapublic boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event);} DecorView 的父类为 ViewGroup，接着会调用 ViewGroup 的 dispatchTouchEvent() 方法。 ViewGroup.dispatchTouchEvent()// ViewGroup.javapublic boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; //根据隐私策略而来决定是否过滤本次触摸事件, if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { // 发生ACTION_DOWN事件, 则取消并清除之前所有的触摸targets cancelAndClearTouchTargets(ev); resetTouchState(); // 重置触摸状态 } // 发生ACTION_DOWN事件或者已经发生过ACTION_DOWN;才进入此区域，主要功能是拦截器 //只有发生过ACTION_DOWN事件，则mFirstTouchTarget != null; final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //可通过调用requestDisallowInterceptTouchEvent，不让父View拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //判断是否允许调用拦截器 if (!disallowIntercept) { //调用拦截方法 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { // 当没有触摸targets，且不是down事件时，开始持续拦截触摸。 intercepted = true; } ... //不取消事件，同时不拦截事件, 并且是Down事件才进入该区域 if (!canceled &amp;&amp; !intercepted) { //把事件分发给所有的子视图，寻找可以获取焦点的视图。 View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // down事件等于0 final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); //清空早先的触摸对象 final int childrenCount = mChildrenCount; //第一次down事件，同时子视图不会空时 if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // 从视图最上层到下层，获取所有能接收该事件的子视图 // 获取一个视图组的先序列表，通过虚拟的Z轴来排序。 final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; /* 从最底层的父视图开始遍历， ** 找寻newTouchTarget，并赋予view与 pointerIdBits； ** 如果已经存在找寻newTouchTarget，说明正在接收触摸事件，则跳出循环。 */ for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // 如果当前视图无法获取用户焦点，则跳过本次循环 if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //如果view不可见，或者触摸的坐标点不在view的范围内，则跳过本次循环 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); // 已经开始接收触摸事件,并退出整个循环。 if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } //重置取消或抬起标志位 //如果触摸位置在child的区域内，则把事件分发给子View或ViewGroup if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // 获取TouchDown的时间点 mLastTouchDownTime = ev.getDownTime(); // 获取TouchDown的Index if (preorderedList != null) { for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } //获取TouchDown的x,y坐标 mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //添加TouchTarget,则mFirstTouchTarget != null。 newTouchTarget = addTouchTarget(child, idBitsToAssign); //表示以及分发给NewTouchTarget alreadyDispatchedToNewTouchTarget = true; break; } ev.setTargetAccessibilityFocus(false); } // 清除视图列表 if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { //将mFirstTouchTarget的链表最后的touchTarget赋给newTouchTarget newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // mFirstTouchTarget赋值是在通过addTouchTarget方法获取的； // 只有处理ACTION_DOWN事件，才会进入addTouchTarget方法。 // 这也正是当View没有消费ACTION_DOWN事件，则不会接收其他MOVE,UP等事件的原因 if (mFirstTouchTarget == null) { //没有触摸target,则由当前ViewGroup来处理 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { //如果View消费ACTION_DOWN事件，那么MOVE,UP等事件相继开始执行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { // 如果ViewGroup拦截了事件，则会向子View分发ACTION_CANCEL事件 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } //当发生抬起或取消事件，更新触摸targets if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } //此处大括号，是if (onFilterTouchEventForSecurity(ev))的结尾 //通知verifier由于当前时间未处理，那么该事件其余的都将被忽略 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled;} 其中 onInterceptTouchEvent() 方法可以实当前 ViewGroup 拦截事件，阻断事件分发流程。 dispatchTransformedTouchEvent()private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // 发生取消操作时，不再执行后续的任何操作 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; //由于某些原因，发生不一致的操作，那么将抛弃该事件 if (newPointerIdBits == 0) { return false; } //分发的主要区域 final MotionEvent transformedEvent; //判断预期的pointer id与事件的pointer id是否相等 if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { //不存在子视图时，ViewGroup调用View.dispatchTouchEvent分发事件，再调用ViewGroup.onTouchEvent来处理事件 handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); //将触摸事件分发给子ViewGroup或View; //如果是ViewGroup，则调用代码(2.1)； //如果是View，则调用代码(3.1)； handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); //调整该事件的位置 } return handled; } transformedEvent = MotionEvent.obtain(event); //拷贝该事件，来创建一个新的MotionEvent } else { //分离事件，获取包含newPointerIdBits的MotionEvent transformedEvent = event.split(newPointerIdBits); } if (child == null) { //不存在子视图时，ViewGroup调用View.dispatchTouchEvent分发事件，再调用ViewGroup.onTouchEvent来处理事件 handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { //将该视图的矩阵进行转换 transformedEvent.transform(child.getInverseMatrix()); } //将触摸事件分发给子ViewGroup或View; //如果是ViewGroup，则调用 ViewGroup 的事件分发方法，如果是View，则调用 View 的事件分发方法处理事件 handled = child.dispatchTouchEvent(transformedEvent); } //回收transformedEvent transformedEvent.recycle(); return handled;} 该方法是 ViewGroup 真正处理事件的地方，分发子 View 来处理事件，过滤掉不相干的 pointer ids。当子视图为 null 时，MotionEvent 将会发送给该 ViewGroup。最终调用 View.dispatchTouchEvent() 方法来分发事件。 View.dispatchTouchEvent()// View.javapublic boolean dispatchTouchEvent(MotionEvent event) { ... final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { //在Down事件之前，如果存在滚动操作则停止。不存在则不进行操作 stopNestedScroll(); } // mOnTouchListener.onTouch优先于onTouchEvent。 if (onFilterTouchEventForSecurity(event)) { //当存在OnTouchListener，且视图状态为ENABLED时，调用onTouch()方法 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; //如果已经消费事件，则返回True } //如果OnTouch（)没有消费Touch事件则调用OnTouchEvent() if (!result &amp;&amp; onTouchEvent(event)) { result = true; //如果已经消费事件，则返回True } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // 处理取消或抬起操作 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} 先由 OnTouchListener.onTouch() 处理事件，如果返回了 true ，表示消费了事件，则不会调用 onTouchEvent() 方法。 若不拦截，继续调用 onTouchEvent() 方法： // View.javapublic boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; // 当View状态为DISABLED，如果可点击或可长按，则返回True，即消费事件 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //当View状态为ENABLED，如果可点击或可长按，则返回True，即消费事件; //与前面的的结合，可得出结论:只要view是可点击或可长按，则消费该事件. if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) { switch (event.getAction()) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { setPressed(true, x, y); } if (!mHasPerformedLongPress) { //这是Tap操作，移除长按回调方法 removeLongPressCallback(); if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } //调用View.OnClickListener if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { mUnsetPressedState.run(); } removeTapCallback(); } break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } //获取是否处于可滚动的视图内 boolean isInScrollingContainer = isInScrollingContainer(); if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); //当处于可滚动视图内，则延迟TAP_TIMEOUT，再反馈按压状态，用来判断用户是否想要滚动。默认延时为100ms postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { //当不再滚动视图内，则立刻反馈按压状态 setPressed(true, x, y); checkForLongClick(0); //检测是否是长按 } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); if (!pointInView(x, y, mTouchSlop)) { removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { removeLongPressCallback(); setPressed(false); } } break; } return true; } return false;} 总结整个事件流程如下图： onInterceptTouchEvent()返回值 true 表示事件拦截， onTouch() 或 onTouchEvent() 返回值 true 表示事件消费。 触摸事件先交由 Activity.dispatchTouchEvent()，再一层层往下分发，当中间的 ViewGroup 都不拦截时，进入最底层的 View 后，开始由最底层的 onTouchEvent() 方法来处理，如果一直不消费，则最后返回到Activity.OnTouchEvent()。 ViewGroup 才有 onInterceptTouchEvent() 拦截方法。在分发过程中，中间任何一层 ViewGroup 都可以直接拦截，则不再往下分发，而是交由发生拦截操作的ViewGroup的 onTouchEvent() 来处理。 子 View 可调用 requestDisallowInterceptTouchEvent() 方法，来设置 disallowIntercept = true，从而阻止父 ViewGroup 的 onInterceptTouchEvent() 拦截操作。 onTouchEvent() 由下往上冒泡时，当中间任何一层的 onTouchEvent 消费该事件，则不再往上传递，表示事件已处理。 如果 View 没有消费 ACTION_DOWN 事件，则之后的 ACTION_MOVE 等事件都不会再接收。 只要 View.onTouchEvent()是可点击或可长按，则消费该事件。 onTouch() 优先于 onTouchEvent() 执行，上面流程图中省略，onTouch() 的位置在 onTouchEvent() 前面。当 onTouch() 返回 true，则不执行 onTouchEvent()，否则会执行 onTouchEvent()。onTouch() 只有 View 设置了OnTouchListener，且是 enable 的才执行该方法。 面试题事件一定会经过 Activity 吗？不是的。我们的程序界面的顶层 ViewGroup，也就是 DecorView 中注册了 Activity 这个 Callback，所以当程序的主界面接收到事件之后会先交给 Activity。 但是，如果是另外的控件树，如 Dialog、PopupWindow 等事件流是不会经过 Activity 的。只有自己界面的事件才会经 Activity。 Activity的分发方法中调用了 onUserInteraction() 方法，你能说说这个方法有什么作用吗？这个方法在 Activity 接收到 ACTION_DOWN 事件的时候会被调用，本身是个空方法，需要开发者自己去重写。 通过官方的注释可以知道，这个方法会在我们以任意的方式开始与 Activity 进行交互的时候被调用。 比较常见的场景就是屏保：当我们一段时间没有操作会显示一张图片，当我们开始与 Activity 交互的时候可在这个方法中取消屏保；另外还有没有操作自动隐藏工具栏，可以在这个方法中让工具栏重新显示。 ViewGroup 是如何分发事件的？ViewGroup 处理事件信息分为三个步骤：拦截、寻找子控件、派发事件。 事件分发中有一个重要的规则：一个触控点的一个事件序列只能给一个 View 处理，除非异常情况。所以如果 ViewGroup 消费了 ACTION_DOWN 事件，那么子 View 将无法收到任何事件。 ViewGroup 第一步会判读这个事件是否需要分发给子 View，如果是则调用 onInterceptTouchEvent() 方法判断是否要进行拦截。 第二步是如果这个事件是 ACTION_DOWN 事件，那么需要为他寻找一个消费此事件的子控件，如果找到则为他创建一个 TouchTarget。 第三步是派发事件，如果存在 TouchTarget，说明找到了消费事件序列的子 View，直接分发给他，如果没有则交给自己处理。 你前面讲到“一个触控点的一个事件序列只能给一个 View 处理，除非异常情况，这里有什么异常情况呢？如果发生异常情况该如何处理？这里的异常情况主要有两点： 被 ViewGroup 拦截 出现界面跳转等其他情况 当事件流中断时，ViewGroup 会发送一个 ACTION_CANCEL 事件给到 View，此时需要做一些状态的恢复工作，如终止动画，恢复 View 大小等等。 事件类型有哪些？ ACTION_DOWN：手指接触时产生的事件。 ACTION_MOVE：手指在屏幕上滑动时产生此事件。 ACTION_UP：手指抬起时产生此事件。 ACTION_CANCEL：取消事件。 ACTION_POINTER_DOWN：当已经有一个手指按下的情况下，另一个手指按下会产生该事件。 ACTION_POINTER_UP：多个手指同时按下的情况下，抬起其中一个手指会产生该事件。 你知道 ViewGroup 是如何将多个手指产生的事件准确分发给不同的子 View 吗？这个问题的关键在于 MotionEvent 以及 ViewGroup 内部的 TouchTarget。 每个 MotionEvent 中都包含了当前屏幕所有触控点的信息，他的内部用了一个数组来存储不同的触控 id 所对应的坐标数值。 当一个子 View 消费了 ACTION_DOWN 事件之后，ViewGroup 会为该 View 创建一个 TouchTarget，这个TouchTarget 就包含了该 View 的实例与触控 id。这里的触控 id 可以是多个，也就是一个 View 可接受多个触控点的事件序列。 当一个 MotionEvent 到来之时，ViewGroup 会将其中的触控点信息拆开，再分别发送给感兴趣的子 View。从而达到精准发送触控点信息的目的。 那 View 支持处理多指信息吗？View 默认是不支持的。他在获取触控点信息的时候并没有传入触控点索引，也就是获取的是 MotionEvent 内部数组中的第一个触控点的信息。多指需要我们自己去重写方法支持他。 View 是如何处理触摸事件的？首先，他会判断是否存在 onTouchListener()，存在则会调用他的 onTouch() 方法来处理事件。如果该方法返回 true 那么就分发结束直接返回。而如果该监听器为 null 或者 onTouch() 方法返回了 false，则会调用 onTouchEvent() 方法来处理事件。 onTouchEvent() 方法中支持了两种监听器：onClickListener () 和 onLongClickListener()。View 会根据不同的触摸情况来调用这两个监听器。同时进入到 onTouchEvent() 方法中，无论该 View 是否是 enable，只要是 clickable，他的分发方法都是返回 true。 总结一下就是：先调用 onTouchListener()，再调用 onClickListener() 和 onLongClickListener()。 在实际中有运用到事件分发吗？ 第一个需求是要设计一个按钮块，按下的时候会缩小高度变低同时变得半透明，放开的时候又会回弹。这个时候就可以在这个按钮的 onTouchEvent() 方法中判断事件类型：down 则开启按下动画，up 则开启释放动画。同时注意接收到 cancel 事件的时候要恢复状态。 第二个是滑动冲突。 解决滑动冲突的核心思路就是把滑动事件根据具体的情况分发给 ViewGroup 或者内部 View。主要的方法有外部拦截法和内部拦截法。 外部拦截法的思路就是在 ViewGroup 中判断滑动的情况，对符合自身滑动的事件进行拦截，对不符合的事件不拦截，给到内部 View。 内部拦截法的思路要求 ViewGroup 拦截除了 down 事件以外的所有事件，然后再内部 View 中判断滑动的情况，对符合自身滑动情况的时间设置禁止拦截标志，对不符合自身滑动情况的事件则取消标志让 ViewGroup 进行拦截。 那外部和内部拦截法该如何选择呢？ 在一般的情况下，外部拦截法不需要对子 View 进行方法重写，比内部拦截法更加简单，推荐使用外部拦截法。 但如果需要在子 View 判断更多的触摸情况时，则使用内部拦截法可更加方法子 View 处理情况。 参考 http://gityuan.com/2015/09/19/android-touch/ https://juejin.cn/post/6922300686638153736","link":"/2021/12/14/android-touch-event/"},{"title":"Android Window 机制","text":"在 Android 中 View 的绘制流程以及 Activity 和 View 的关系，都离不开 Window，本文将介绍 Window 的概念，以及在 Android 系统中的作用。在文末会放上几个与 WMS 有关的面试题，已巩固这部分知识点。注：文中源码来源于 Android API 30 Window 存在的意义Window 的概念在用户界面中是比较重要的，比如 Windows、MacOS 系统，View 都是显示在各个独立窗口中的，可以说 Window 是对 View 载体。在 Android 中，为了管理各 Window，Android 在系统进程中创建了一个系统服务 WindowManagerService，而 View 只能显示在对应的 Window 中。由于每一个 App 都是一个进程，所以 WMS 设计为系统进程，以方便统一管理。 Activity、Window 和 View 的关系每个 App 都可以有很多窗口，为了方便管理页面的跳转回退逻辑，Android 系统为了单一职责封装了 Activity，并将 Activity 放入到栈中，并由 AMS 统一调度，又通过迪米特法则将 Window 屏蔽，并暴露了各个生命周期方法，让开发者专注于 View 的开发。 每个 Activity 包含了一个 Window（由 PhoneWindow 实现）。而 PhoneWindow 将 DecorView 作为了一个应用窗口的根 View，DecorView 又把屏幕划分为了两个区域：一个是 TitleView，也就是 ActionBar 或者 TitleBar，一个是 ContentView，通过 setContentView() 设置。 层级关系如下图所示： ActivityActivity 不处理加载视图的逻辑，在 attach() 的时候创建 Window 对象，在 onResume() 后通过 WindowManager 添加 View。 Window每一个 Window 都管理着一个 View 树，View 必须依附在 Window 中才能展示。Activity 内部可以有多个窗口，例如在页面上弹出一个 Dialog，其中 Dialog 是一个单独的窗口。View 的测量、布局和绘制动作都是在一个 View 树种进行的，所以窗口之间 View 的改动是互不影响的。 WindowManagerWindowManager 是 Window 的管理类，但不直接管理 Window。WindowManager 与 Window 之间的关系是一个典型的桥接模式。而 WindowManager 使用 WindowManagerGlobal 通过 IWindowManager 接口与 WindowManagerService （也就是 WMS）进行交互，并由 WMS 完成具体的窗口管理工作。 public abstract class Window { ... /** * Set the window manager for use by this Window to, for example, * display panels. This is &lt;em&gt;not&lt;/em&gt; used for displaying the * Window itself -- that must be done by the client. * * @param wm The window manager for adding new windows. */ public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; // 默认关闭硬件加速 mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); // 如果传入的 WindowManager 为空，则通过 getSystemService 获取 WindowManager。 if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } // 将 WindowManager 和 Window 绑定，创建一个 WindowManagerImpl mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); }} DecorViewDecorView 是 View 树的顶级 View，它是 FrameLayout 的子类。根据 Activity 设置的 Theme，DecorView 会有不同布局。但无论布局怎么变，DecorView 都有一个 Id 为 R.id.content 的 FrameLayout。Activity.setContentView() 方法就是在这个FrameLayout 中添加子 View 的。 ViewRootImplViewRootImpl 是连接 WindowManager 和 DecorView 的纽带，View 的测量、布局和绘制均是通过 ViewRootImpl 来完成的。 Activity 是如何通过 Window 将 View 展示出来的这个需要从 Activity 的启动开始，Activity 的启动是通过 ActivityThread.handleLaunchActivity() 开始的： public final class ActivityThread extends ClientTransactionHandler { // 省略... private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { //省略代码... //performLaunchActivity Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //handleResumeActivity handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed); //省略代码... } } // 省略...} performLaunchActivity()完成 Activity 的创建，调用 Activity.attach() 方法，将 Window 创建出来，然后调用 Activity.onCreate() 方法。 handleResumeActivity()调用 Activity.onResume() 方法，处理 View 的展示。 1. performLaunchActivity()以下为 performLaunchActivity() 方法的核心代码： public final class ActivityThread extends ClientTransactionHandler { // 省略... private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } // 创建 Context ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); // 创建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } // Activity resources must be initialized with the same loaders as the // application context. appContext.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); appContext.setOuterContext(activity); // **调用 Activity.attach() 方法** activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } // 调用 Activity.onCreate() 方法 activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; mLastReportedWindowingMode.put(activity.getActivityToken(), config.windowConfiguration.getWindowingMode()); } r.setState(ON_CREATE); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. synchronized (mResourcesManager) { mActivities.put(r.token, r); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); } } return activity; } // 省略...} performLaunchActivity() 方法主要做了以下几个事情： 创建 Context 创建 Activity 调用 Activity.attach() 创建 Window，并关联 WindowManager 调用 Activity.onCreate() 方法 Activity.attach()在 performLaunchActivity() 代码中，创建 Window 的逻辑是在 Activity.attach() 方法中的，我们跟进来看下： public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient { // 省略... final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); // 创建 Window mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } // 设置 UI 线程 mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } // Window 与 WindowManager 建立关联 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); setAutofillOptions(application.getAutofillOptions()); setContentCaptureOptions(application.getContentCaptureOptions()); } // 省略...} Activity.attach() 方法主要做了以下几个事情： 创建 Window 对象 给 Window 设置 WindowManager 设置 UI 线程 Activity.setContentView()通常我们会在 Activity.onCreate() 方法中调用 setContentView() 方法，将 View 设置到当前页面中。Activity.setContentView() 又调用了 PhoneWindow.setContentView()： public class PhoneWindow extends Window implements MenuBuilder.Callback { // 省略... private DecorView mDecor; // setContentView() 传过来的 View 会被加载到到 mContentParent 中。mContentParent 的 Id是 R.id.content private ViewGroup mContentParent; // 省略... @Override public void setContentView(View view, ViewGroup.LayoutParams params) { if (mContentParent == null) { installDecor(); }else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } // 省略... } // 省略... private void installDecor() { if (mDecor == null) { // 初始化 DecorView mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } if (mContentParent == null) { mContentParent = generateLayout(mDecor); // 省略... } } // 省略...} 首次加载时，会执行 installDecor() 方法初始化 DecorView，调用 Activity.setContentView() 方法就会将 View 添加到 ID 为 R.id.content 的 FrameLayout 中。 2. handleResumeActivity()以下为 handleResumeActivity() 的核心代码： public final class ActivityThread extends ClientTransactionHandler { // 省略... @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // **调用 Activity.onResume() 方法** // TODO Push resumeArgs into the activity for consideration final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) { // We didn't actually resume the activity, so skipping any follow-up actions. return; } if (mActivitiesToBeDestroyed.containsKey(token)) { // Although the activity is resumed, it is going to be destroyed. So the following // UI operations are unnecessary and also prevents exception because its token may // be gone that window manager cannot recognize it. All necessary cleanup actions // performed below will be done while handling destruction. return; } final Activity a = r.activity; if (localLOGV) { Slog.v(TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); } final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityTaskManager.getService().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); // 将 DecorView 设置为不可见 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } // **通过 WindowManager 加载 DecorView** if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } else { // The activity will get a callback for this {@link LayoutParams} change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); } } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { performConfigurationChangedForActivity(r, r.newConfig); if (DEBUG_CONFIGURATION) { Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig); } r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; // 将 DecorView 设置为可见状态 if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } // 省略...} handleResumeActivity() 方法为本文的重点，主要做了以下几个事情： 首先调用了 Activity.onResume() 生命周期 将 DecorView 设置为不可见 通过 WindowManager 加载 DecorView 将 DecorView 设置为可见 WindowManager 加载 DecorView因为 WindowManagerImpl 为 WindowManger 的实现，所以下面来看一下 WindowMangerImpl.addView() 方法。 public final class WindowManagerImpl implements WindowManager { private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); // 省略... private IBinder mDefaultToken; /** * Sets the window token to assign when none is specified by the client or * available from the parent window. * * @param token The default token to assign. */ public void setDefaultToken(IBinder token) { mDefaultToken = token; } @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId()); } // 省略... private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) { // Only use the default token if we don't have a parent window. if (mDefaultToken != null &amp;&amp; mParentWindow == null) { if (!(params instanceof WindowManager.LayoutParams)) { throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); } // Only use the default token if we don't already have a token. final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (wparams.token == null) { wparams.token = mDefaultToken; } } } // 省略...} 其中 addView() 方法逻辑很简短，直接调用 WindowManagerGlobal.addView() 方法。在调用之前，还会执 applyDefaultToken() 方法，这个的作用是给 DecorView 加一个身份标识，表示当前的 DecorView 属于那个 Activity，然后将当前的 DecorView 绘制到 Activity 中。 WindowManagerGlobal 加载 View紧接着进入 WindowManagerGlobal.addView() 方法，以下为核心代码： public final class WindowManagerGlobal { private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); // 省略... public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) { // 省略一些校验... final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; // 省略... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // 省略... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView, userId); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) { removeViewLocked(index, true); } throw e; } } } // 省略...} 在 WindowManagerGlobal 中，首先会创建 ViewRootImpl，将 View、ViewRootImpl 和 LayoutParams 放入到 List 中，后边更新 UI 使用，三者因下标相同，所以可以一一对应。然后调用 ViewRootImpl.setView() 加载 View。 ViewRootImpl.setView()ViewRootImpl.setView() 方法比较长，提取了一下其中的关键逻辑： public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRendererDrawCallbacks { // 省略... View mView; // 省略... public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) { synchronized (this) { if (mView == null) { mView = view; // 省略... requestLayout(); // 省略... // 通过 IPC 通信通知 WMS 渲染界面 res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame, mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mDisplayCutout, inputChannel, mTempInsets, mTempControls); // 省略... } } } // 省略... @Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } // 省略... void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } // 省略...} 在 setView() 方法中，首先调用了 requestLayout()，然后通过 IPC 通信，通知 WMS 渲染界面。跟进 requestLayout() 方法中，首先需要检查当前线程，然后调用 scheduleTraversals()。 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRendererDrawCallbacks { // 省略... final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); // 省略... void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } // 省略... void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } // 省略...} 其调用链为 setView() -&gt; requestLayout() -&gt; scheduleTraversals() -&gt; doTraversal() -&gt; performTraversals()。 View 的绘制流程接下来就是 View 树的绘制流程，我们进到 performTraversals() 方法中看一下关键代码： public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRendererDrawCallbacks { // 省略... private void performTraversals() { // 省略... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // 省略... performLayout(lp, mWidth, mHeight); // 省略... performDraw(); // 省略... } // 省略...} View 的绘制分三步，测量、布局和绘制，详细内容将在另一边文章展开。(TODO) 相关面试题为什么要要设计 Window？ 使 Activity 的职责更加单一。 View 树的控制封装到 Window 之后，Activity 只需要管理 Window 即可。 子线程是否可以更新 UI？从 ActivityThread 的源码得知，View 的绘制是发生在 Activity onResume 生命周期之后的，所以在 onCreate() 方法、第一次进入 onResume() 方法时，都是可以在其他线程更新 UI 的。关于子线程更新 UI 的更多问题，可以转到这篇文章看下。 可以在 Activity.onCreate() 中获取到 View 的宽和高吗，在 Activity.onResume() 中呢？ 如果直接获取或者用 Handler 获取，是无法获取到 View 的宽高的，因为 View 的绘制流程是在 onResume() 方法之后的，但是如果采用延时 Handler 是可能会获取到宽高的。使用 View.post() 方法可以获取到宽高。 如果直接获取或者用 Handler 获取，在第一次进入到 onResume() 方法时，跟在 onCreate() 的情况是一样的，当再次进入到 onResume() 方法，是可以获取到的。同样，使用 View.post() 方法可以获取到宽高。 为什么使用 View.post() 方法可以获取到宽高？首先我们先看下 View.post() 的逻辑： public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { // 省略... public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true; } // 省略...} 在 onCreate() 中 attachInfo 为空，则先将 runnable 放入到队列中，然后这个队列中的任务会在 performTraversals() 中执行。 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRendererDrawCallbacks { // 省略... private void performTraversals() { // 省略... // Execute enqueued actions on every traversal in case a detached view enqueued an action getRunQueue().executeActions(mAttachInfo.mHandler); // 省略... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // 省略... performLayout(lp, mWidth, mHeight); // 省略... performDraw(); // 省略... } // 省略...} 通过 View.post() 添加的任务，是在 View 绘制流程的开始阶段，将所有任务重新发送到消息队列的尾部，此时相关任务的执行已经在 View 绘制任务之后，即 View 绘制流程已经结束，此时便可以正确获取到 View 的宽高了。","link":"/2021/12/14/android-window/"},{"title":"iTerm 快捷键速查","text":"平时经常使用 iTerm2 作为终端应用，本文记录一些常用的快捷键，方便日后使用。 光标 ⌃U清除当前行control + u 到行首 ⌃Acontrol + a 到行尾 ⌃Econtrol + e 前进后退 ⌃F / ⌃Bcontrol + f/b 删除当前光标的字符 ⌃Dcontrol + d 删除光标之前的字符 ⌃Hcontrol + h 删除光标之前的单词 ⌃Wcontrol + w 删除到文本末尾 ⌃Kcontrol + k 交换光标处文本 ⌃Tcontrol + t 清屏 ⌘Rcommand + r 标签新建标签 ⌘Tcommand + t 关闭标签 ⌘Wcommand + w 切换标签 ⌘→ / ⌘←command + 左右方向键 分屏垂直分屏 ⌘Dcommand + d 水平分屏 ⌘⇧Dcommand + shift + d 切换屏幕 ⌘⌥→ \\ ⌘⌥←command + option + 方向键 其他显示 Toolbelt ⌘⇧Bcommand + shift + b 查看历史命令 ⌘;command + ; 查看剪贴板历史 ⌘⇧Hcommand + shift + h","link":"/2021/12/31/iterm-shortcut-key/"},{"title":"上传 Android 库到 MavenCentral","text":"最近在学习 Android 中的注解处理器，仿写了一个 ActivityStarter 来解决 Activity 启动传参问题，为了方便使用决定将库上传到远程仓库，之前都是上传到 JCenter 的，也有现成的插件，十分方便，但目前 JCenter 已不能发布新的项目，所以打算将项目上传到 MavenCentral，以此文章来记录上传的流程。 JCenter 服务更新 JFrog（这家公司维护着很多 Android 项目使用的 JCenter 工件库）已于 2021 年 3 月 31 日将 JCenter 设为只读代码库。根据公告，JCenter 将无限期地提供现有工件供用户下载。 在 JCenter 上发布工件的开发者应该将其软件包迁移到新的托管服务，如 Maven Central。 使用 JCenter 中依赖项的开发者将需要找到相应依赖项的更新后版本所在的新位置。 注册 Sonatype 账号注册地址：https://issues.sonatype.org/secure/ForgotLoginDetails.jspa 创建问题注册好账号之后，需要创建一个问题 根据提示填写好基本信息之后，点击创建就可以了。 注：Group Id 填写时需要确认是否为自己的域名，如 com.xxx，则拥有此域名，如果没有个人域名，则可使用 GitHub 的域名，io.github.用户名，如：io.github.qihuan92 创建好问题之后，就可以根据问题详情页中的注释来进行操作了，比如我的域名填写的是 GitHub 的，所以需要创建一个名称为问题编号的仓库，后边等待问题关闭就可以了。 项目 Gradle 配置上传 Gradle 配置文件在根项目创建一个 publish.gradle 文件 apply plugin: 'maven-publish'def isAndroidProject = project.hasProperty('android')task sourcesJar(type: Jar) { archiveClassifier.set('sources') if (isAndroidProject) { from android.sourceSets.main.java.srcDirs } else { from sourceSets.main.allSource }}if (isAndroidProject) { task javadoc(type: Javadoc) { options.encoding = 'UTF-8' source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) android.libraryVariants.all { variant -&gt; if (variant.name == 'release') { owner.classpath += variant.javaCompile.classpath } } }} else { javadoc { options.encoding = 'UTF-8' }}task javadocJar(type: Jar, dependsOn: javadoc) { archiveClassifier.set('javadoc') from javadoc.destinationDir}afterEvaluate { publishing { repositories { maven { name = &quot;OSSRH&quot; url = &quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot; credentials { username = project.ossrhMavenUser // sonatype 用户名 password = project.ossrhMavenPassword // sonatype 密码 } } } publications { release(MavenPublication) { // 如果判断是否为 Android Module if (isAndroidProject) { from components.release } else { from components.java } artifact(sourcesJar) artifact(javadocJar) groupId project.publishGroupId // groupId artifactId project.artifactId // artifactId version project.activityStarterVersionName // 版本号 pom { name = project.artifactId // artifactId description = 'ActivityStarter' // 项目描述 url = 'https://github.com/qihuan92/ActivityStarter' // 项目地址 // 许可相关配置 licenses { license { name = 'ActivityStarter License' url = 'https://github.com/qihuan92/ActivityStarter/blob/master/LICENSE' } } // 开发者信息 developers { developer { id = 'qihuan' name = 'qihuan' email = 'qihuan92@126.com' } } // scm 配置 scm { connection = 'scm:git:github.com/qihuan92/ActivityStarter.git' developerConnection = 'scm:git:ssh://github.com/qihuan92/ActivityStarter.git' url = 'https://github.com/qihuan92/ActivityStarter/tree/master' } } } } }} 然后在需要上传的 module 的 builder.gradle 中添加依赖 ext { artifactId = 'activitystarter-runtime' // TODO 填写需要上传项目的 artifactId}apply from: rootProject.file('publish.gradle') 签名配置生成一个 GPG 秘钥因为上传 MavenCentral 需要发布者签名验证，所以需要生成一个 GPG 秘钥。可以从 gnupg.org 下载对应的客户端，MacOS 的下载地址为 GPG Suite ，Windows 为 Gpg4win。 打开客户端后点击创建秘钥，选项如下： 创建完成之后就会提示上传到秘钥服务器了。 发布项目时需要一个秘钥的 Key，可通过以下命令生成，注 XXX 为指纹的后八位 gpg --export-secret-keys XXX | base64 配置签名信息到 publish.gradle 文件apply plugin: 'signing'signing { useInMemoryPgpKeys( project.signingKeyId, // 指纹的后八位 project.signingKey, // 导出的 base64 指纹信息 project.signingPassword, // 签名的密码 ) sign publishing.publications} 完整的 publish.gradle 文件apply plugin: 'maven-publish'apply plugin: 'signing'def isAndroidProject = project.hasProperty('android')task sourcesJar(type: Jar) { archiveClassifier.set('sources') if (isAndroidProject) { from android.sourceSets.main.java.srcDirs } else { from sourceSets.main.allSource }}if (isAndroidProject) { task javadoc(type: Javadoc) { options.encoding = 'UTF-8' source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) android.libraryVariants.all { variant -&gt; if (variant.name == 'release') { owner.classpath += variant.javaCompile.classpath } } }} else { javadoc { options.encoding = 'UTF-8' }}task javadocJar(type: Jar, dependsOn: javadoc) { archiveClassifier.set('javadoc') from javadoc.destinationDir}afterEvaluate { publishing { repositories { maven { name = &quot;OSSRH&quot; url = &quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot; credentials { username = project.ossrhMavenUser password = project.ossrhMavenPassword } } maven { name = &quot;GitHubPackages&quot; url = &quot;https://maven.pkg.github.com/qihuan92/ActivityStarter&quot; credentials { username = project.githubMavenUser password = project.githubMavenToken } } } publications { release(MavenPublication) { if (isAndroidProject) { from components.release } else { from components.java } artifact(sourcesJar) artifact(javadocJar) groupId project.publishGroupId artifactId project.artifactId version project.activityStarterVersionName pom { name = project.artifactId description = 'ActivityStarter' url = 'https://github.com/qihuan92/ActivityStarter' licenses { license { name = 'ActivityStarter License' url = 'https://github.com/qihuan92/ActivityStarter/blob/master/LICENSE' } } developers { developer { id = 'qihuan' name = 'qihuan' email = 'qihuan92@126.com' } } scm { connection = 'scm:git:github.com/qihuan92/ActivityStarter.git' developerConnection = 'scm:git:ssh://github.com/qihuan92/ActivityStarter.git' url = 'https://github.com/qihuan92/ActivityStarter/tree/master' } } } } }}signing { useInMemoryPgpKeys( project.signingKeyId, project.signingKey, project.signingPassword, ) sign publishing.publications} 发布到 MavenCentral相关命令项目配置好之后就可以发布项目到 MavenCentral 了 # yourmodule 为需要上传的模块名./gradlew yourmodule:publishReleasePublicationToOSSRHRepository 登录网页发布执行上述命令成功后，就可以登录 https://s01.oss.sonatype.org 查看待发布的库了，如下图所示： 在 Staging Repositories 页签可以看到刚刚上传的包，然后选中点击 Close 按钮，如果关闭成功，就可以点击 Release 按钮来发布项目了。","link":"/2021/08/13/%E4%B8%8A%E4%BC%A0-Android-%E5%BA%93%E5%88%B0-MavenCentral/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Activity","slug":"Activity","link":"/tags/Activity/"},{"name":"APT","slug":"APT","link":"/tags/APT/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"AMS","slug":"AMS","link":"/tags/AMS/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"Window","slug":"Window","link":"/tags/Window/"},{"name":"WMS","slug":"WMS","link":"/tags/WMS/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"iTerm","slug":"iTerm","link":"/tags/iTerm/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"终端","slug":"终端","link":"/categories/%E7%BB%88%E7%AB%AF/"}],"pages":[]}